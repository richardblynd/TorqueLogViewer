@page "/"
@using System.Globalization
@using System.Text
@using System.Text.RegularExpressions
@inject IJSRuntime JS

<div class="layout-container">
    @if (IsDataLoaded)
    {
        <TorqueLogViewer.Components.SensorSidebar 
            AvailableSensors="@AvailableSensors"
            SelectedSensors="@SelectedSensors"
            SensorColorMapping="@SensorColorMapping"
            OnSensorToggle="@HandleSensorToggle"
            CurrentPoint="@CurrentPoint"
            AllLogData="@LogData"
            GaugeSensors="@GaugeSensors"
            OnGaugeToggle="@HandleGaugeToggle"
            @bind-IsExpanded="@IsSensorSidebarExpanded" />
    }

    <div class="content-area">
        @if (IsGaugesVisible)
        {
            <div class="gauges-area">
                <div class="gauges-container">
                    @foreach (var sensor in GaugeSensors)
                    {
                        // Get custom scale config or use data-driven defaults
                        var scaleConfig = GetGaugeScaleConfig(sensor);
                        
                        double minValue, maxValue;
                        int majorTickCount, minorTicksPerMajor;
                        
                        if (scaleConfig != null)
                        {
                            // Use custom configuration
                            minValue = scaleConfig.MinValue;
                            maxValue = scaleConfig.MaxValue;
                            majorTickCount = scaleConfig.MajorTickCount;
                            minorTicksPerMajor = scaleConfig.MinorTicksPerMajor;
                        }
                        else
                        {
                            // Use data-driven defaults
                            minValue = Math.Min(0, GetSensorMinNumeric(sensor));
                            maxValue = GetSensorMaxNumeric(sensor);
                            majorTickCount = 6;
                            minorTicksPerMajor = 1;
                        }
                        
                        var currentValue = GetGaugeValueNumeric(sensor);
                        var percentage = CalculateGaugePercentage(currentValue, minValue, maxValue);
                        
                        // Determine decimal places for display based on sensor type
                        string valueFormat = "F1";
                        string scaleFormat = "F0";
                        if (scaleConfig != null && (sensor.ToLower().Contains("turbo") || sensor.ToLower().Contains("boost")))
                        {
                            valueFormat = "F2";
                            scaleFormat = "F1";
                        }
                        
                        // Gauge configuration constants
                        const double gaugeCenterX = 100;
                        const double gaugeCenterY = 90;
                        const double gaugeRadius = 90;
                        const double startAngle = -225;
                        const double endAngle = 135;
                        const double angleRange = 270;
                        const double majorTickLength = 12;
                        const double minorTickLength = 6;
                        const double numberOffset = 10;
                        const double needleLengthRatio = 0.80; // 80% of radius
                        const double centerDotRadius = 5;
                        const double digitalValueY = 135; // Moved up inside the circle
                        
                        var needleAngle = startAngle + (percentage * angleRange);
                        
                        <div class="gauge-wrapper">
                            <div class="gauge-display">
                                <div class="gauge-header">
                                    <span class="gauge-title" title="@sensor">@(sensor.Length > 20 ? sensor.Substring(0, 20) + "..." : sensor)</span>
                                    <div class="gauge-stats">
                                        <span class="gauge-stat-min" title="Minimum"><span class="icon-min">&#9660;</span> @minValue.ToString(scaleFormat)</span>
                                        <span class="gauge-stat-max" title="Maximum"><span class="icon-max">&#9650;</span> @maxValue.ToString(scaleFormat)</span>
                                        <button class="gauge-remove" @onclick="() => RemoveGauge(sensor)" title="Remove gauge">&times;</button>
                                    </div>
                                </div>
                                <div class="gauge-body">
                                    <svg viewBox="0 0 200 180" class="gauge-svg">
                                        <circle class="gauge-face" cx="@gaugeCenterX" cy="@gaugeCenterY" r="@gaugeRadius"/>
                                        @for (int i = 0; i <= (majorTickCount - 1) * (minorTicksPerMajor + 1); i++)
                                        {
                                            var angle = startAngle + (i * angleRange / ((majorTickCount - 1) * (minorTicksPerMajor + 1)));
                                            var isMajor = i % (minorTicksPerMajor + 1) == 0;
                                            var tickLength = isMajor ? majorTickLength : minorTickLength;
                                            var tickStartRadius = gaugeRadius - tickLength;
                                            
                                            var x1 = gaugeCenterX + tickStartRadius * Math.Cos(angle * Math.PI / 180);
                                            var y1 = gaugeCenterY + tickStartRadius * Math.Sin(angle * Math.PI / 180);
                                            var x2 = gaugeCenterX + gaugeRadius * Math.Cos(angle * Math.PI / 180);
                                            var y2 = gaugeCenterY + gaugeRadius * Math.Sin(angle * Math.PI / 180);
                                            
                                            <line class="@(isMajor ? "gauge-tick-major" : "gauge-tick")" 
                                                  x1="@x1.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)" 
                                                  y1="@y1.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)" 
                                                  x2="@x2.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)" 
                                                  y2="@y2.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)"/>
                                            
                                            if (isMajor)
                                            {
                                                var majorTickIndex = i / (minorTicksPerMajor + 1);
                                                var numberRadius = tickStartRadius - numberOffset;
                                                var numX = gaugeCenterX + numberRadius * Math.Cos(angle * Math.PI / 180);
                                                var numY = gaugeCenterY + numberRadius * Math.Sin(angle * Math.PI / 180) + 4;
                                                var displayValue = minValue + (majorTickIndex / (double)(majorTickCount - 1)) * (maxValue - minValue);
                                                <text>
                                                    <text class="gauge-number" 
                                                          x="@numX.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)" 
                                                          y="@numY.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)">
                                                        @displayValue.ToString(scaleFormat)
                                                    </text>
                                                </text>
                                            }
                                        }
                                        @{
                                            var needleLength = gaugeRadius * needleLengthRatio;
                                            var needleX = gaugeCenterX + needleLength * Math.Cos(needleAngle * Math.PI / 180);
                                            var needleY = gaugeCenterY + needleLength * Math.Sin(needleAngle * Math.PI / 180);
                                        }
                                        <line class="gauge-needle" 
                                              x1="@gaugeCenterX" 
                                              y1="@gaugeCenterY" 
                                              x2="@needleX.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)" 
                                              y2="@needleY.ToString("F2", System.Globalization.CultureInfo.InvariantCulture)"/>
                                        <circle class="gauge-center-dot" cx="@gaugeCenterX" cy="@gaugeCenterY" r="@centerDotRadius"/>
                                        <text class="gauge-digital-value" x="@gaugeCenterX" y="@digitalValueY" text-anchor="middle">@currentValue.ToString(valueFormat)</text>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    }
                    @if (GaugeSensors.Count == 0)
                    {
                        <div class="no-gauges-message">
                            <p>No gauges added yet. Click the 🕐 icon next to a sensor to add a gauge.</p>
                        </div>
                    }
                </div>
            </div>
        }

        @if (IsMapVisible)
        {
            <div class="map-area">
                <div id="map" class="map-container"></div>
            </div>
        }

        <div class="chart-area">
            <div class="controls-bar">
                <div class="control-group">
                    <label>Load Log (CSV):</label>
                    <InputFile OnChange="HandleFileSelected" />
                </div>

                @if (!IsDataLoaded)
                {
                    <div class="control-group">
                        <label>Sampling Mode:</label>
                        <select @bind="SamplingMode" class="form-select-small">
                            <option value="None">No Sampling (All Points)</option>
                            <option value="Time">Time Interval</option>
                            <option value="Index">Every N Points</option>
                        </select>
                    </div>

                    @if (SamplingMode == "Time")
                    {
                        <div class="control-group">
                            <label>Interval (ms):</label>
                            <input type="number" @bind="SamplingTimeMs" min="10" max="10000" step="10" class="form-input-small" />
                        </div>
                    }
                    else if (SamplingMode == "Index")
                    {
                        <div class="control-group">
                            <label>Every N points:</label>
                            <input type="number" @bind="SamplingEveryN" min="1" max="1000" step="1" class="form-input-small" />
                        </div>
                    }
                }

                @if (IsDataLoaded)
                {
                    <button class="btn-toggle-map" @onclick="ToggleGaugesVisibility" title="@(IsGaugesVisible ? "Hide Gauges" : "Show Gauges")">
                        @(IsGaugesVisible ? "🕐 Hide Gauges" : "🕐 Show Gauges")
                    </button>

                    <button class="btn-toggle-map" @onclick="ToggleMapVisibility" title="@(IsMapVisible ? "Hide Map" : "Show Map")">
                        @(IsMapVisible ? "🗺️ Hide Map" : "🗺️ Show Map")
                    </button>

                    <div class="info-badge">
                        <span>📊 @LogData.Count points loaded</span>
                        @if (TotalPointsBeforeSampling > LogData.Count)
                        {
                            <span style="margin-left: 10px; color: #ff9800;">
                                (sampled from @TotalPointsBeforeSampling)
                            </span>
                        }
                    </div>

                    <button class="btn-reset" @onclick="ResetZoom">⟲ Reset Zoom</button>

                    <button class="btn-sync" @onclick="CopySensorsToClipboard" title="Copy selected sensors">
                        📋 Copy Sensors
                    </button>

                    <button class="btn-sync" @onclick="ImportSensorsFromClipboard" title="Import sensors from clipboard">
                        📥 Import Sensors
                    </button>

                    <button class="btn-virtual" @onclick="OpenVirtualSensorModal" title="Create virtual sensor">
                        ➕ Virtual Sensor
                    </button>

                    <button class="btn-export" @onclick="MarkStartPoint" title="Mark start of range">
                        📍 Mark Start
                    </button>

                    <button class="btn-export" @onclick="MarkEndPoint" title="Mark end of range">
                        📍 Mark End
                    </button>

                    <button class="btn-export" @onclick="ExportRangeToClipboard" title="Export range to clipboard">
                        📤 Export Range
                    </button>

                    <div class="control-group">
                        <label>X Axis:</label>
                        <select @onchange="OnXAxisChanged">
                            <option value="DeviceTime">Device Time (Default)</option>
                            <option value="Index">Index (Sequence)</option>
                        </select>
                    </div>
                }
            </div>

            <div class="chart-wrapper">
                <div class="chart-container">
                    <canvas id="logChart"></canvas>
                </div>
            </div>
            
            <div id="scrollbarContainer" class="scrollbar-container" style="display: none;">
                <label class="scrollbar-label">Navigation:</label>
                <input type="range" id="chartScrollbar" class="chart-scrollbar" />
            </div>

            <div class="info-panel">
                @if (CurrentPoint != null)
                {
                    <div>
                        <strong>Selected Point (@CurrentIndex):</strong>
                        Time: @CurrentPoint.DeviceTime.ToString() |
                        Time: @CurrentPoint.DeviceTime.ToString("HH:mm:ss") |
                        Speed: @GetValue(CurrentPoint, "Speed (GPS)(km/h)") km/h |
                        RPM: @GetValue(CurrentPoint, "Engine RPM(rpm)")
                        <span style="margin-left: 20px; color: #666; font-size: 0.85rem;">
                            💡 Use ← → arrow keys to navigate between points
                        </span>
                    </div>
                }
                else if (IsDataLoaded)
                {
                    <div style="color: #666;">
                        Click on a point in the chart to select it, then use ← → arrow keys to navigate
                    </div>
                }
                @if (StartIndex >= 0 || EndIndex >= 0)
                {
                    <div style="margin-top: 5px; color: #ff9800;">
                        <strong>Export Range:</strong>
                        @if (StartIndex >= 0)
                        {
                            <span>Start: @StartIndex</span>
                        }
                        @if (EndIndex >= 0)
                        {
                            <span style="margin-left: 10px;">End: @EndIndex</span>
                        }
                        @if (StartIndex >= 0 && EndIndex >= 0)
                        {
                            <span style="margin-left: 10px;">(@(EndIndex - StartIndex + 1) points)</span>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@* Virtual Sensor Modal *@
@if (ShowVirtualSensorModal)
{
    <div class="modal-overlay" @onclick="CloseVirtualSensorModal">
        <div class="modal-content" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h3>Create Virtual Sensor</h3>
                <button class="btn-close" @onclick="CloseVirtualSensorModal">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Virtual Sensor Name:</label>
                    <input type="text" @bind="VirtualSensorName" placeholder="e.g., Power Calculation" class="form-input" />
                </div>

                <div class="form-group">
                    <label>Operation Type:</label>
                    <select @bind="VirtualSensorOperation" @bind:after="OnOperationTypeChanged" class="form-select">
                        <option value="+">Addition (+)</option>
                        <option value="-">Subtraction (-)</option>
                        <option value="*">Multiplication (×)</option>
                        <option value="/">Division (÷)</option>
                        <option value="ChangeTime">Change Time (Progressive time since value changed)</option>
                        <option value="ChangeTimeMs">Change Time Ms (Progressive time in milliseconds)</option>
                        <option value="MaxChangeTime">Max Change Time (Constant duration between changes)</option>
                        <option value="MaxChangeTimeMs">Max Change Time Ms (Constant duration in milliseconds)</option>
                    </select>
                </div>

                @if (IsChangeTimeOperation)
                {
                    <div class="form-group">
                        <label>Sensor to Monitor:</label>
                        <select @bind="VirtualSensorA" class="form-select">
                            <option value="">-- Select Sensor --</option>
                            @foreach (var sensor in AvailableSensors)
                            {
                                <option value="@sensor">@sensor</option>
                            }
                        </select>
                    </div>

                    <div class="form-group" style="background-color: #e3f2fd; padding: 10px; border-radius: 4px; font-size: 0.85rem;">
                        @if (VirtualSensorOperation == "ChangeTime" || VirtualSensorOperation == "ChangeTimeMs")
                        {
                            <strong>ℹ️ Progressive Change Time Operation</strong>
                            <p style="margin: 5px 0 0 0;">
                                This operation calculates the <strong>progressive time elapsed</strong> since the sensor value last changed.
                                The value starts at 0 when the sensor changes and increases continuously until the next change.
                                Useful for real-time monitoring of sensor response delays and state duration.
                            </p>
                        }
                        else if (VirtualSensorOperation == "MaxChangeTime" || VirtualSensorOperation == "MaxChangeTimeMs")
                        {
                            <strong>ℹ️ Max Change Time Operation</strong>
                            <p style="margin: 5px 0 0 0;">
                                This operation calculates the <strong>total duration</strong> between value changes.
                                The value remains constant between changes, showing the complete duration the sensor held each value.
                                Useful for analyzing stability periods, dwell time, and maximum latency between state transitions.
                            </p>
                        }
                    </div>
                }
                else
                {
                    <div class="form-group">
                        <label>First Sensor:</label>
                        <select @bind="VirtualSensorA" class="form-select">
                            <option value="">-- Select Sensor --</option>
                            @foreach (var sensor in AvailableSensors)
                            {
                                <option value="@sensor">@sensor</option>
                            }
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Second Sensor:</label>
                        <select @bind="VirtualSensorB" class="form-select">
                            <option value="">-- Select Sensor --</option>
                            @foreach (var sensor in AvailableSensors)
                            {
                                <option value="@sensor">@sensor</option>
                            }
                        </select>
                    </div>
                }
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" @onclick="CloseVirtualSensorModal">Cancel</button>
                <button class="btn-create" @onclick="CreateVirtualSensor">Create</button>
            </div>
        </div>
    </div>
}

@code {
    private bool IsDataLoaded = false;
    private List<LogPoint> LogData = new();
    private List<string> AvailableSensors = new();
    private HashSet<string> SelectedSensors = new();
    private bool IsSensorSidebarExpanded = true;
    private bool IsMapVisible = false;

    // Sampling configuration
    private string SamplingMode = "None"; // None, Time, Index
    private int SamplingTimeMs = 1000; // Sample every 100ms by default
    private int SamplingEveryN = 10; // Sample every 10 points by default
    private int TotalPointsBeforeSampling = 0;

    // Current state
    private LogPoint? CurrentPoint;
    private int CurrentIndex = -1;
    private string XAxisMode = "DeviceTime";

    // Export range tracking
    private int StartIndex = -1;
    private int EndIndex = -1;

    // Color mapping for sensors
    private static readonly string[] ChartColors = { "#FF5733", "#33FF57", "#3357FF", "#FF33F6", "#33FFF6", "#F3FF33", "#FF8C33" };
    private Dictionary<string, string> SensorColorMapping = new();

    // Marked range points
    private LogPoint? StartPoint = null;
    private LogPoint? EndPoint = null;

    // Virtual sensor state
    private bool ShowVirtualSensorModal = false;
    private string VirtualSensorName = string.Empty;
    private string VirtualSensorA = string.Empty;
    private string VirtualSensorB = string.Empty;
    private string VirtualSensorOperation = "+";
    private List<VirtualSensor> VirtualSensors = new();
    private bool IsChangeTimeOperation => VirtualSensorOperation == "ChangeTime" ||
                                          VirtualSensorOperation == "ChangeTimeMs" ||
                                          VirtualSensorOperation == "MaxChangeTime" ||
                                          VirtualSensorOperation == "MaxChangeTimeMs";

    // Gauges state
    private bool IsGaugesVisible = false;
    private HashSet<string> GaugeSensors = new();

    // Gauge configuration system
    private class GaugeScaleConfig
    {
        public double MinValue { get; set; }
        public double MaxValue { get; set; }
        public int MajorTickCount { get; set; }
        public int MinorTicksPerMajor { get; set; } = 1;
        
        public GaugeScaleConfig(double minValue, double maxValue, int majorTickCount, int minorTicksPerMajor = 1)
        {
            MinValue = minValue;
            MaxValue = maxValue;
            MajorTickCount = majorTickCount;
            MinorTicksPerMajor = minorTicksPerMajor;
        }
    }

    private GaugeScaleConfig GetGaugeScaleConfig(string sensorName)
    {
        var sensorLower = sensorName.ToLower();
        
        // RPM sensors: 1000 to 7000, major tick every 1000 (7 major ticks: 1000, 2000, 3000, 4000, 5000, 6000, 7000)
        if (sensorLower.Contains("rpm"))
        {
            return new GaugeScaleConfig(
                minValue: 1000,
                maxValue: 7000,
                majorTickCount: 7,
                minorTicksPerMajor: 1
            );
        }
        
        // Turbo/Boost sensors: -1 to 2 bar, major tick every 0.5 (7 major ticks: -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0)
        // Minor ticks every 0.1 (4 minor ticks between each major tick)
        if (sensorLower.Contains("turbo") || sensorLower.Contains("boost"))
        {
            return new GaugeScaleConfig(
                minValue: -1.0,
                maxValue: 2.0,
                majorTickCount: 7,      // -1.0, -0.5, 0.0, 0.5, 1.0, 1.5, 2.0
                minorTicksPerMajor: 4   // 4 minor ticks = 5 divisions of 0.1 between each 0.5 major tick
            );
        }
        
        // Add more sensor-specific configurations here as needed:
        // Example: Speed sensors
        // if (sensorLower.Contains("speed") || sensorLower.Contains("km/h"))
        // {
        //     return new GaugeScaleConfig(0, 200, 5, 4); // 0-200 km/h, 5 major ticks, 4 minor ticks between each major
        // }
        
        // Default: use data-driven min/max
        return null; // null indicates to use dynamic range from data
    }

    // Mapping of Portuguese month abbreviations to numbers
    private static readonly Dictionary<string, int> MonthMap = new(StringComparer.OrdinalIgnoreCase)
    {
        { "jan", 1 }, { "fev", 2 }, { "mar", 3 }, { "abr", 4 },
        { "mai", 5 }, { "jun", 6 }, { "jul", 7 }, { "ago", 8 },
        { "set", 9 }, { "out", 10 }, { "nov", 11 }, { "dez", 12 }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Initialize chart with .NET reference
            await JS.InvokeVoidAsync("torqueApp.initChart", DotNetObjectReference.Create(this));

            // Only initialize the map if it's visible on first render
            if (IsMapVisible)
            {
                await JS.InvokeVoidAsync("torqueApp.initMap", DotNetObjectReference.Create(this));
            }
        }
    }

    private async Task InitializeMapIfNeeded()
    {
        // Initialize map on demand when it becomes visible
        try
        {
            await JS.InvokeVoidAsync("torqueApp.initMap", DotNetObjectReference.Create(this));
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
        }
    }

    private async Task ToggleMapVisibility()
    {
        IsMapVisible = !IsMapVisible;
        StateHasChanged();

        // If map is now visible and hasn't been initialized yet, initialize it
        if (IsMapVisible)
        {
            await Task.Delay(100); // Small delay to ensure DOM is updated
            await InitializeMapIfNeeded();

            // If we have data, redraw the route
            if (IsDataLoaded)
            {
                var route = LogData
                    .Where(p => p.Latitude != 0 && p.Longitude != 0)
                    .Select(p => new[] { p.Latitude, p.Longitude })
                    .ToList();

                await JS.InvokeVoidAsync("torqueApp.drawRoute", route);
            }
        }
    }

    private void ToggleGaugesVisibility()
    {
        IsGaugesVisible = !IsGaugesVisible;
        StateHasChanged();
    }

    private void HandleGaugeToggle(string sensor)
    {
        if (GaugeSensors.Contains(sensor))
        {
            GaugeSensors.Remove(sensor);
        }
        else
        {
            GaugeSensors.Add(sensor);
        }
        StateHasChanged();
    }

    private void RemoveGauge(string sensor)
    {
        GaugeSensors.Remove(sensor);
        StateHasChanged();
    }

    private string GetGaugeValue(string sensor)
    {
        if (CurrentPoint?.RawData != null && CurrentPoint.RawData.ContainsKey(sensor))
        {
            return CurrentPoint.RawData[sensor].ToString("F1");
        }
        return "-";
    }

    private double GetGaugeValueNumeric(string sensor)
    {
        if (CurrentPoint?.RawData != null && CurrentPoint.RawData.ContainsKey(sensor))
        {
            return CurrentPoint.RawData[sensor];
        }
        return 0;
    }

    private double GetSensorMinNumeric(string sensor)
    {
        if (LogData == null || LogData.Count == 0) return 0;

        double min = double.MaxValue;
        foreach (var point in LogData)
        {
            if (point.RawData.ContainsKey(sensor))
            {
                double value = point.RawData[sensor];
                if (value < min) min = value;
            }
        }

        return min != double.MaxValue ? min : 0;
    }

    private double GetSensorMaxNumeric(string sensor)
    {
        if (LogData == null || LogData.Count == 0) return 100;

        double max = double.MinValue;
        foreach (var point in LogData)
        {
            if (point.RawData.ContainsKey(sensor))
            {
                double value = point.RawData[sensor];
                if (value > max) max = value;
            }
        }

        return max != double.MinValue ? max : 100;
    }

    private double CalculateGaugePercentage(double current, double min, double max)
    {
        if (max == min) return 0.5;

        var percentage = (current - min) / (max - min);

        if (percentage < 0) percentage = 0;
        if (percentage > 1) percentage = 1;

        return percentage;
    }

    private string GetSensorMin(string sensor)
    {
        return GetSensorMinNumeric(sensor).ToString("F1");
    }

    private string GetSensorMax(string sensor)
    {
        return GetSensorMaxNumeric(sensor).ToString("F1");
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss}] === START FILE LOADING ===");

        var file = e.File;
        if (file == null) return;

        // Show loading indicator
        await JS.InvokeVoidAsync("torqueApp.showLoading", true);
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 0, "Starting file load...");

        try
        {
            var streamStartTime = DateTime.Now;
            Console.WriteLine($"[{streamStartTime:HH:mm:ss}] Starting file stream read (size: {file.Size} bytes)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 5, "Opening file stream...");

            // Size limit increased to 50MB for larger files
            using var stream = file.OpenReadStream(50 * 1024 * 1024);
            using var reader = new StreamReader(stream);

            var readStartTime = DateTime.Now;
            Console.WriteLine($"[{readStartTime:HH:mm:ss}] Reading file content");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 10, "Reading file content...");

            var content = await reader.ReadToEndAsync();

            var readEndTime = DateTime.Now;
            var readDuration = (readEndTime - readStartTime).TotalMilliseconds;
            Console.WriteLine($"[{readEndTime:HH:mm:ss}] File read completed (duration: {readDuration:F2}ms, size: {content.Length} characters)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 20, "File read complete");

            var parseStartTime = DateTime.Now;
            Console.WriteLine($"[{parseStartTime:HH:mm:ss}] Starting CSV parse");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 25, "Starting CSV parse...");

            // Parse on the UI thread with progress updates
            await ParseCSVAsync(content);

            var parseEndTime = DateTime.Now;
            var parseDuration = (parseEndTime - parseStartTime).TotalMilliseconds;
            Console.WriteLine($"[{parseEndTime:HH:mm:ss}] CSV parse completed (duration: {parseDuration:F2}ms)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 95, "Parse complete");

            var uiStartTime = DateTime.Now;
            Console.WriteLine($"[{uiStartTime:HH:mm:ss}] Updating UI");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 98, "Updating UI...");

            // Update UI
            StateHasChanged();

            var uiEndTime = DateTime.Now;
            var uiDuration = (uiEndTime - uiStartTime).TotalMilliseconds;
            Console.WriteLine($"[{uiEndTime:HH:mm:ss}] UI updated (duration: {uiDuration:F2}ms)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 100, "Complete!");

            // Longer delay to show 100% before closing
            await Task.Delay(500);
        }
        finally
        {
            await JS.InvokeVoidAsync("torqueApp.showLoading", false);

            var endTime = DateTime.Now;
            var totalDuration = (endTime - startTime).TotalMilliseconds;
            Console.WriteLine($"[{endTime:HH:mm:ss}] === END FILE LOADING ===");
            Console.WriteLine($"[{endTime:HH:mm:ss}] TOTAL TIME: {totalDuration:F2}ms ({totalDuration / 1000:F2}s)");
        }
    }

    private async Task ParseCSVAsync(string csvContent)
    {
        var parseStartTime = DateTime.Now;
        Console.WriteLine($"[{parseStartTime:HH:mm:ss}] ParseCSV: Starting");

        LogData.Clear();
        AvailableSensors.Clear();
        SelectedSensors.Clear();
        VirtualSensors.Clear();
        TotalPointsBeforeSampling = 0;

        var splitStartTime = DateTime.Now;
        Console.WriteLine($"[{splitStartTime:HH:mm:ss}] ParseCSV: Splitting lines");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 30, "Splitting lines...");
        await Task.Yield(); // Allow UI to update

        var lines = csvContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);

        var splitEndTime = DateTime.Now;
        var splitDuration = (splitEndTime - splitStartTime).TotalMilliseconds;
        Console.WriteLine($"[{splitEndTime:HH:mm:ss}] ParseCSV: Lines split (duration: {splitDuration:F2}ms, total: {lines.Length} lines)");

        if (lines.Length < 2) return;

        var headerStartTime = DateTime.Now;
        Console.WriteLine($"[{headerStartTime:HH:mm:ss}] ParseCSV: Parsing headers");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 35, "Parsing headers...");
        await Task.Yield();

        // Parse headers - optimized
        var headers = ParseCsvLineOptimized(lines[0]);
        for (int i = 0; i < headers.Length; i++)
        {
            headers[i] = headers[i].Trim().Trim('"');
        }

        var headerEndTime = DateTime.Now;
        var headerDuration = (headerEndTime - headerStartTime).TotalMilliseconds;
        Console.WriteLine($"[{headerEndTime:HH:mm:ss}] ParseCSV: Headers parsed (duration: {headerDuration:F2}ms, total: {headers.Length} columns)");

        var timeDetectionStartTime = DateTime.Now;
        Console.WriteLine($"[{timeDetectionStartTime:HH:mm:ss}] ParseCSV: Detecting time column");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 38, "Detecting time column...");
        await Task.Yield();

        // Detect time column
        int timeColumnIndex = -1;
        if (lines.Length > 1)
        {
            var firstDataLine = ParseCsvLineOptimized(lines[1]);

            for (int i = 0; i < Math.Min(2, firstDataLine.Length); i++)
            {
                firstDataLine[i] = firstDataLine[i].Trim().Trim('"');
            }

            if (firstDataLine.Length > 0 && Regex.IsMatch(firstDataLine[0].Trim(), @"^\d{1,2}:\d{1,2}:\d{1,2}"))
            {
                timeColumnIndex = 0;
            }
            else if (firstDataLine.Length > 1 && (firstDataLine[1].Contains("-") || Regex.IsMatch(firstDataLine[1].Trim(), @"\d{1,2}:\d{1,2}:\d{1,2}")))
            {
                timeColumnIndex = 1;
            }
        }

        if (timeColumnIndex == -1)
        {
            timeColumnIndex = 1;
        }

        var timeDetectionEndTime = DateTime.Now;
        var timeDetectionDuration = (timeDetectionEndTime - timeDetectionStartTime).TotalMilliseconds;
        Console.WriteLine($"[{timeDetectionEndTime:HH:mm:ss}] ParseCSV: Time column detected (duration: {timeDetectionDuration:F2}ms, index: {timeColumnIndex})");

        var sensorIndexStartTime = DateTime.Now;
        Console.WriteLine($"[{sensorIndexStartTime:HH:mm:ss}] ParseCSV: Identifying sensors");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 40, "Identifying sensors...");
        await Task.Yield();

        // Pre-compute sensor indices for faster access
        var ignoreCols = new HashSet<string> { "GPS Time", "Device Time", "Longtitude", "Longitude", "Latitude" };
        var sensorIndices = new List<(int index, string name)>();

        for (int i = 0; i < headers.Length; i++)
        {
            if (!ignoreCols.Contains(headers[i]))
            {
                AvailableSensors.Add(headers[i]);
                sensorIndices.Add((i, headers[i]));
            }
        }

        var sensorIndexEndTime = DateTime.Now;
        var sensorIndexDuration = (sensorIndexEndTime - sensorIndexStartTime).TotalMilliseconds;
        Console.WriteLine($"[{sensorIndexEndTime:HH:mm:ss}] ParseCSV: Sensors identified (duration: {sensorIndexDuration:F2}ms, total: {AvailableSensors.Count} sensors)");

        var columnIndexStartTime = DateTime.Now;
        Console.WriteLine($"[{columnIndexStartTime:HH:mm:ss}] ParseCSV: Calculating column indices");

        // Pre-calculate column indices
        int longitudeIndex = Array.IndexOf(headers, "Longitude");
        if (longitudeIndex < 0)
        {
            longitudeIndex = Array.IndexOf(headers, "Longtitude");
        }
        int latitudeIndex = Array.IndexOf(headers, "Latitude");

        // Pre-allocate list with estimated capacity
        var allPoints = new List<LogPoint>(lines.Length - 1);

        var columnIndexEndTime = DateTime.Now;
        var columnIndexDuration = (columnIndexEndTime - columnIndexStartTime).TotalMilliseconds;
        Console.WriteLine($"[{columnIndexEndTime:HH:mm:ss}] ParseCSV: Indices calculated (duration: {columnIndexDuration:F2}ms)");

        var dataParseStartTime = DateTime.Now;
        Console.WriteLine($"[{dataParseStartTime:HH:mm:ss}] ParseCSV: Parsing data points");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 45, $"Parsing data points (0/{lines.Length - 1})...");
        await Task.Yield();

        // Parse data points with optimized loop
        int progressUpdateInterval = Math.Max((lines.Length - 1) / 20, 100); // Update progress every ~5% or every 100 lines

        for (int i = 1; i < lines.Length; i++)
        {
            var cols = ParseCsvLineOptimized(lines[i]);
            if (cols.Length != headers.Length) continue;

            // Clean quotes only where needed
            for (int j = 0; j < cols.Length; j++)
            {
                var span = cols[j].AsSpan().Trim();
                if (span.Length > 0 && span[0] == '"')
                {
                    cols[j] = span.Trim('"').ToString();
                }
                else if (span.Length != cols[j].Length)
                {
                    cols[j] = span.ToString();
                }
            }

            var point = new LogPoint
            {
                RawData = new Dictionary<string, double>(sensorIndices.Count)
            };

            // Parse Time
            if (timeColumnIndex >= 0 && timeColumnIndex < cols.Length)
            {
                point.DeviceTime = ParseDeviceTimeOptimized(cols[timeColumnIndex]);
            }

            // Parse Lat/Lon
            if (longitudeIndex >= 0 && longitudeIndex < cols.Length)
                point.Longitude = ParseDoubleOptimized(cols[longitudeIndex]);
            if (latitudeIndex >= 0 && latitudeIndex < cols.Length)
                point.Latitude = ParseDoubleOptimized(cols[latitudeIndex]);

            // Parse Sensors using pre-computed indices
            foreach (var (index, name) in sensorIndices)
            {
                if (index < cols.Length)
                {
                    point.RawData[name] = ParseDoubleOptimized(cols[index]);
                }
            }

            allPoints.Add(point);

            // Update progress periodically
            if (i % progressUpdateInterval == 0)
            {
                int progressPercentage = 45 + (int)((i / (double)(lines.Length - 1)) * 35); // 45-80%
                int pointsParsed = i;
                await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", progressPercentage,
                    $"Parsing data points ({pointsParsed:N0}/{lines.Length - 1:N0})...");
                await Task.Yield(); // Allow UI to update
            }
        }

        var dataParseEndTime = DateTime.Now;
        var dataParseDuration = (dataParseEndTime - dataParseStartTime).TotalMilliseconds;
        Console.WriteLine($"[{dataParseEndTime:HH:mm:ss}] ParseCSV: Data points parsed (duration: {dataParseDuration:F2}ms, total: {allPoints.Count} points)");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 80, "Data parsing complete");
        await Task.Yield();

        TotalPointsBeforeSampling = allPoints.Count;

        var samplingStartTime = DateTime.Now;
        Console.WriteLine($"[{samplingStartTime:HH:mm:ss}] ParseCSV: Applying sampling (mode: {SamplingMode})");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 82, $"Applying sampling ({SamplingMode})...");
        await Task.Yield();

        // Apply sampling
        LogData = ApplySampling(allPoints);

        var samplingEndTime = DateTime.Now;
        var samplingDuration = (samplingEndTime - samplingStartTime).TotalMilliseconds;
        Console.WriteLine($"[{samplingEndTime:HH:mm:ss}] ParseCSV: Sampling applied (duration: {samplingDuration:F2}ms, points after sampling: {LogData.Count})");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 85, "Sampling complete");
        await Task.Yield();

        IsDataLoaded = true;

        var visualizationStartTime = DateTime.Now;
        Console.WriteLine($"[{visualizationStartTime:HH:mm:ss}] ParseCSV: Updating visualization");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 88, "Updating map and chart...");
        await Task.Yield();

        UpdateVisualization();

        var visualizationEndTime = DateTime.Now;
        var visualizationDuration = (visualizationEndTime - visualizationStartTime).TotalMilliseconds;
        Console.WriteLine($"[{visualizationEndTime:HH:mm:ss}] ParseCSV: Visualization updated (duration: {visualizationDuration:F2}ms)");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 92, "Visualization complete");

        var parseEndTime = DateTime.Now;
        var totalParseDuration = (parseEndTime - parseStartTime).TotalMilliseconds;
        Console.WriteLine($"[{parseEndTime:HH:mm:ss}] ParseCSV: Completed (total duration: {totalParseDuration:F2}ms)");
    }

    private void OnOperationTypeChanged()
    {
        // Reset second sensor when switching to ChangeTime
        if (IsChangeTimeOperation)
        {
            VirtualSensorB = string.Empty;
        }
        StateHasChanged();
    }

    private string[] ParseCsvLineOptimized(string line)
    {
        // Fast path for lines without quotes
        if (line.IndexOf('"') < 0)
        {
            return line.Split(',');
        }

        // Optimized parsing for quoted fields
        var result = new List<string>(50);
        var currentField = new StringBuilder(32);
        bool insideQuotes = false;

        for (int i = 0; i < line.Length; i++)
        {
            char c = line[i];

            if (c == '"')
            {
                if (insideQuotes && i + 1 < line.Length && line[i + 1] == '"')
                {
                    currentField.Append('"');
                    i++;
                }
                else
                {
                    insideQuotes = !insideQuotes;
                }
            }
            else if (c == ',' && !insideQuotes)
            {
                result.Add(currentField.ToString());
                currentField.Clear();
            }
            else
            {
                currentField.Append(c);
            }
        }

        result.Add(currentField.ToString());
        return result.ToArray();
    }

    private DateTime ParseDeviceTimeOptimized(string timeStr)
    {
        if (string.IsNullOrWhiteSpace(timeStr))
            return DateTime.MinValue;

        var span = timeStr.AsSpan().Trim();

        // Fast path: Simple time format HH:mm:ss.fff
        if (span.Length >= 8 && span.Length <= 12 && span.IndexOf('-') < 0)
        {
            if (TryParseSimpleTime(span, out DateTime simpleTime))
                return simpleTime;
        }

        // Fallback to original parsing
        return ParseDeviceTime(timeStr);
    }

    private bool TryParseSimpleTime(ReadOnlySpan<char> span, out DateTime result)
    {
        result = DateTime.MinValue;

        int firstColon = span.IndexOf(':');
        if (firstColon < 0) return false;

        int secondColon = span.Slice(firstColon + 1).IndexOf(':');
        if (secondColon < 0) return false;
        secondColon += firstColon + 1;

        if (!int.TryParse(span.Slice(0, firstColon), out int hour)) return false;
        if (!int.TryParse(span.Slice(firstColon + 1, secondColon - firstColon - 1), out int minute)) return false;

        int dotIndex = span.Slice(secondColon).IndexOf('.');
        int secondEnd = dotIndex >= 0 ? secondColon + dotIndex : span.Length;

        if (!int.TryParse(span.Slice(secondColon + 1, secondEnd - secondColon - 1), out int second)) return false;

        int millisecond = 0;
        if (dotIndex >= 0 && secondEnd + 1 < span.Length)
        {
            var msSpan = span.Slice(secondEnd + 1);
            if (msSpan.Length > 3) msSpan = msSpan.Slice(0, 3);

            if (int.TryParse(msSpan, out int ms))
            {
                millisecond = msSpan.Length switch
                {
                    1 => ms * 100,
                    2 => ms * 10,
                    _ => ms
                };
            }
        }

        try
        {
            var today = DateTime.Today;
            result = new DateTime(today.Year, today.Month, today.Day, hour, minute, second, millisecond);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private double ParseDoubleOptimized(string val)
    {
        if (string.IsNullOrEmpty(val)) return 0;

        var span = val.AsSpan().Trim();
        if (span.IsEmpty || (span.Length == 1 && span[0] == '-')) return 0;

        if (double.TryParse(span, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out double result))
            return result;

        return 0;
    }

    private void UpdateVisualization()
    {
        if (!IsDataLoaded) return;

        // 1. Update Map (Route) - only if map is visible
        if (IsMapVisible)
        {
            // Filter points with valid lat/lon (different from 0 or null if possible)
            var route = LogData
                .Where(p => p.Latitude != 0 && p.Longitude != 0)
                .Select(p => new[] { p.Latitude, p.Longitude })
                .ToList();

            JS.InvokeVoidAsync("torqueApp.drawRoute", route);
        }

        // 2. Update Chart
        UpdateChartData();
    }

    private void UpdateChartData()
    {
        if (LogData.Count == 0) return;

        // Pre-allocate arrays
        string[] labels = new string[LogData.Count];

        if (XAxisMode == "DeviceTime")
        {
            for (int i = 0; i < LogData.Count; i++)
            {
                labels[i] = LogData[i].DeviceTime.ToString("HH:mm:ss.fff");
            }
        }
        else
        {
            for (int i = 0; i < LogData.Count; i++)
            {
                labels[i] = i.ToString();
            }
        }

        var datasets = new List<object>(SelectedSensors.Count);
        int colorIdx = 0;

        foreach (var sensor in SelectedSensors)
        {
            if (!SensorColorMapping.ContainsKey(sensor))
            {
                SensorColorMapping[sensor] = ChartColors[colorIdx % ChartColors.Length];
            }

            // Pre-allocate array
            var rawData = new double[LogData.Count];

            for (int i = 0; i < LogData.Count; i++)
            {
                rawData[i] = LogData[i].RawData.TryGetValue(sensor, out double value) ? value : 0;
            }

            // Optimized min/max
            double min = double.MaxValue;
            double max = double.MinValue;

            foreach (var v in rawData)
            {
                if (v < min) min = v;
                if (v > max) max = v;
            }

            double range = max - min;
            var normalizedData = new double[rawData.Length];

            if (range == 0)
            {
                Array.Fill(normalizedData, 0.5);
            }
            else
            {
                for (int i = 0; i < rawData.Length; i++)
                {
                    normalizedData[i] = (rawData[i] - min) / range;
                }
            }

            datasets.Add(new
            {
                label = sensor,
                data = normalizedData,
                originalData = rawData,
                borderColor = SensorColorMapping[sensor],
                backgroundColor = "transparent",
                borderWidth = 2,
                pointRadius = 0,
                pointHoverRadius = 4,
                tension = 0.1
            });

            colorIdx++;
        }

        JS.InvokeVoidAsync("torqueApp.updateChart", labels, datasets);
    }

    private void ToggleSensor(string sensor, bool isChecked)
    {
        if (isChecked) SelectedSensors.Add(sensor);
        else SelectedSensors.Remove(sensor);
        UpdateChartData();
    }

    private void HandleSensorToggle((string sensor, bool isSelected) args)
    {
        if (args.isSelected)
        {
            SelectedSensors.Add(args.sensor);
        }
        else
        {
            SelectedSensors.Remove(args.sensor);
        }
        UpdateChartData();
        StateHasChanged();
    }

    private void OnXAxisChanged(ChangeEventArgs e)
    {
        XAxisMode = e.Value?.ToString() ?? "DeviceTime";
        UpdateChartData();
    }

    // Called by JS when the map is clicked
    [JSInvokable]
    public void OnMapClick(double lat, double lng)
    {
        // Find the closest point in the list
        // (This is a simple linear search, for giant logs using KD-Tree would be better, but C# WASM handles ~10k points well)
        var closest = LogData
            .Select((p, index) => new { Point = p, Index = index, Dist = Math.Pow(p.Latitude - lat, 2) + Math.Pow(p.Longitude - lng, 2) })
            .OrderBy(x => x.Dist)
            .FirstOrDefault();

        if (closest != null)
        {
            SelectPoint(closest.Index);
        }
    }

    // Called by JS when the chart is clicked
    [JSInvokable]
    public void OnChartClick(int index)
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss.fff}] OnChartClick: Started (index: {index})");

        SelectPoint(index);

        var endTime = DateTime.Now;
        var duration = (endTime - startTime).TotalMilliseconds;
        Console.WriteLine($"[{endTime:HH:mm:ss.fff}] OnChartClick: Completed (duration: {duration:F2}ms)");
    }

    private void SelectPoint(int index)
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss.fff}] SelectPoint: Started (index: {index})");

        if (index < 0 || index >= LogData.Count)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SelectPoint: Invalid index, returning");
            return;
        }

        var step1Time = DateTime.Now;
        CurrentIndex = index;
        CurrentPoint = LogData[index];
        Console.WriteLine($"[{step1Time:HH:mm:ss.fff}] SelectPoint: Set CurrentPoint (duration: {(step1Time - startTime).TotalMilliseconds:F2}ms)");

        // REMOVED StateHasChanged() - we'll call it only after JS operations complete
        // This prevents re-rendering the entire page (including SensorSidebar) synchronously

        // 1. Update visual on map - only if map is visible
        if (IsMapVisible)
        {
            var step3StartTime = DateTime.Now;
            JS.InvokeVoidAsync("torqueApp.highlightPointOnMap", CurrentPoint.Latitude, CurrentPoint.Longitude);
            var step3Time = DateTime.Now;
            Console.WriteLine($"[{step3Time:HH:mm:ss.fff}] SelectPoint: highlightPointOnMap called (duration: {(step3Time - step3StartTime).TotalMilliseconds:F2}ms)");
        }

        // 2. Update visual on chart
        var step4StartTime = DateTime.Now;
        JS.InvokeVoidAsync("torqueApp.highlightPointOnChart", index);
        var step4Time = DateTime.Now;
        Console.WriteLine($"[{step4Time:HH:mm:ss.fff}] SelectPoint: highlightPointOnChart called (duration: {(step4Time - step4StartTime).TotalMilliseconds:F2}ms)");

        // 3. Now trigger StateHasChanged to update the UI (async, won't block)
        var step5StartTime = DateTime.Now;
        _ = InvokeAsync(StateHasChanged);
        var step5Time = DateTime.Now;
        Console.WriteLine($"[{step5Time:HH:mm:ss.fff}] SelectPoint: InvokeAsync(StateHasChanged) queued (duration: {(step5Time - step5StartTime).TotalMilliseconds:F2}ms)");

        var endTime = DateTime.Now;
        var totalDuration = (endTime - startTime).TotalMilliseconds;
        Console.WriteLine($"[{endTime:HH:mm:ss.fff}] SelectPoint: Completed (total duration: {totalDuration:F2}ms)");
    }

    private string GetValue(LogPoint p, string key)
    {
        if (p.RawData.ContainsKey(key)) return p.RawData[key].ToString("F2");
        return "-";
    }

    // Internal Model Class
    public class LogPoint
    {
        public DateTime DeviceTime { get; set; }
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public Dictionary<string, double> RawData { get; set; } = new();
    }

    // Method invoked by JavaScript when pressing Left (-1) or Right (1) arrow keys
    [JSInvokable]
    public void MoveSelection(int direction)
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss.fff}] MoveSelection: Started (direction: {direction})");

        if (!IsDataLoaded || LogData.Count == 0)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MoveSelection: No data loaded, returning");
            return;
        }

        // If no point is selected, start from the beginning
        if (CurrentIndex < 0)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MoveSelection: No point selected, starting from index 0");
            SelectPoint(0);
            return;
        }

        // Calculate the new index
        int newIndex = CurrentIndex + direction;

        // Safety limits
        if (newIndex < 0)
        {
            newIndex = 0;
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MoveSelection: Index capped at minimum (0)");
        }

        if (newIndex >= LogData.Count)
        {
            newIndex = LogData.Count - 1;
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MoveSelection: Index capped at maximum ({LogData.Count - 1})");
        }

        // If it changed, select
        if (newIndex != CurrentIndex)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MoveSelection: Moving from index {CurrentIndex} to {newIndex}");
            SelectPoint(newIndex);
        }
        else
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MoveSelection: Already at boundary, no movement");
        }

        var endTime = DateTime.Now;
        var totalDuration = (endTime - startTime).TotalMilliseconds;
        Console.WriteLine($"[{endTime:HH:mm:ss.fff}] MoveSelection: Completed (total duration: {totalDuration:F2}ms)");
    }

    private async Task ResetZoom()
    {
        await JS.InvokeVoidAsync("torqueApp.resetChartZoom");
    }

    private async Task CopySensorsToClipboard()
    {
        if (!IsDataLoaded || SelectedSensors.Count == 0)
        {
            await JS.InvokeVoidAsync("alert", "No sensors selected to copy.");
            return;
        }

        // Create sensor configuration object
        var sensorConfig = SelectedSensors.Select(sensor => new
        {
            Name = sensor,
            Color = SensorColorMapping.ContainsKey(sensor) ? SensorColorMapping[sensor] : ChartColors[0]
        }).ToList();

        // Serialize to JSON
        var json = System.Text.Json.JsonSerializer.Serialize(sensorConfig, new System.Text.Json.JsonSerializerOptions
        {
            WriteIndented = true
        });

        // Copy to clipboard via JavaScript
        await JS.InvokeVoidAsync("torqueApp.copyToClipboard", json);
    }

    private async Task ImportSensorsFromClipboard()
    {
        if (!IsDataLoaded)
        {
            await JS.InvokeVoidAsync("alert", "Please load a CSV file first.");
            return;
        }

        try
        {
            // Read from clipboard via JavaScript
            var json = await JS.InvokeAsync<string>("torqueApp.readFromClipboard");

            if (string.IsNullOrWhiteSpace(json))
            {
                await JS.InvokeVoidAsync("alert", "Clipboard is empty.");
                return;
            }

            // Deserialize JSON
            var sensorConfig = System.Text.Json.JsonSerializer.Deserialize<List<SensorConfiguration>>(json);

            if (sensorConfig == null || sensorConfig.Count == 0)
            {
                await JS.InvokeVoidAsync("alert", "Invalid data format.");
                return;
            }

            // Clear current selection
            SelectedSensors.Clear();

            // Apply imported sensors and colors
            foreach (var config in sensorConfig)
            {
                // Only add if the sensor exists in the current log
                if (AvailableSensors.Contains(config.Name))
                {
                    SelectedSensors.Add(config.Name);
                    SensorColorMapping[config.Name] = config.Color;
                }
            }

            // Update the visualization
            UpdateChartData();
            StateHasChanged();

            await JS.InvokeVoidAsync("alert", $"{SelectedSensors.Count} sensors imported successfully!");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", $"Error importing: {ex.Message}");
        }
    }

    private void MarkStartPoint()
    {
        if (CurrentIndex < 0)
        {
            JS.InvokeVoidAsync("alert", "Please select a point on the chart first.");
            return;
        }

        StartIndex = CurrentIndex;

        // Clear end if it's before start
        if (EndIndex >= 0 && EndIndex < StartIndex)
        {
            EndIndex = -1;
        }

        StateHasChanged();
    }

    private void MarkEndPoint()
    {
        if (CurrentIndex < 0)
        {
            JS.InvokeVoidAsync("alert", "Please select a point on the chart first.");
            return;
        }

        if (StartIndex < 0)
        {
            JS.InvokeVoidAsync("alert", "Please mark the start point first.");
            return;
        }

        if (CurrentIndex < StartIndex)
        {
            JS.InvokeVoidAsync("alert", "End point must be after start point.");
            return;
        }

        EndIndex = CurrentIndex;
        StateHasChanged();
    }

    private async Task ExportRangeToClipboard()
    {
        if (!IsDataLoaded)
        {
            await JS.InvokeVoidAsync("alert", "No data loaded.");
            return;
        }

        if (StartIndex < 0 || EndIndex < 0)
        {
            await JS.InvokeVoidAsync("alert", "Please mark both start and end points first.");
            return;
        }

        if (StartIndex > EndIndex)
        {
            await JS.InvokeVoidAsync("alert", "Invalid range: start point is after end point.");
            return;
        }

        try
        {
            // Extract the range of data
            var rangeData = LogData.Skip(StartIndex).Take(EndIndex - StartIndex + 1).ToList();

            // Create export object
            var exportData = new LogDataExport
            {
                Data = rangeData
            };

            // Serialize to JSON
            var json = System.Text.Json.JsonSerializer.Serialize(exportData, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = true
            });

            // Copy to clipboard
            await JS.InvokeVoidAsync("torqueApp.copyToClipboard", json);

            await JS.InvokeVoidAsync("alert", $"Exported {rangeData.Count} data points to clipboard!");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", $"Error exporting: {ex.Message}");
        }
    }

    private void OpenVirtualSensorModal()
    {
        // Reset form fields
        VirtualSensorName = string.Empty;
        VirtualSensorA = string.Empty;
        VirtualSensorB = string.Empty;
        VirtualSensorOperation = "+";
        ShowVirtualSensorModal = true;
    }

    private void CloseVirtualSensorModal()
    {
        ShowVirtualSensorModal = false;
    }

    private async Task CreateVirtualSensor()
    {
        // Validation
        if (string.IsNullOrWhiteSpace(VirtualSensorName))
        {
            await JS.InvokeVoidAsync("alert", "Please enter a name for the virtual sensor.");
            return;
        }

        if (string.IsNullOrWhiteSpace(VirtualSensorA))
        {
            await JS.InvokeVoidAsync("alert", IsChangeTimeOperation ? "Please select a sensor to monitor." : "Please select the first sensor.");
            return;
        }

        // For non-ChangeTime operations, validate second sensor
        if (!IsChangeTimeOperation)
        {
            if (string.IsNullOrWhiteSpace(VirtualSensorB))
            {
                await JS.InvokeVoidAsync("alert", "Please select both sensors.");
                return;
            }

            if (VirtualSensorA == VirtualSensorB)
            {
                await JS.InvokeVoidAsync("alert", "Please select two different sensors.");
                return;
            }
        }

        // Check if virtual sensor name already exists
        if (AvailableSensors.Contains(VirtualSensorName) || VirtualSensors.Any(vs => vs.Name == VirtualSensorName))
        {
            await JS.InvokeVoidAsync("alert", "A sensor with this name exists. Please choose a different name.");
            return;
        }

        // Create the virtual sensor
        var virtualSensor = new VirtualSensor
        {
            Name = VirtualSensorName,
            SensorA = VirtualSensorA,
            SensorB = VirtualSensorB,
            Operation = VirtualSensorOperation,
            IsVirtual = true
        };

        VirtualSensors.Add(virtualSensor);

        // Calculate values for all log points
        CalculateVirtualSensorValues(virtualSensor);

        // Add to available sensors list
        AvailableSensors.Add(VirtualSensorName);

        // Automatically select the new virtual sensor
        SelectedSensors.Add(VirtualSensorName);

        // Close modal
        CloseVirtualSensorModal();

        // Update chart
        UpdateChartData();
        StateHasChanged();

        await JS.InvokeVoidAsync("alert", $"Virtual sensor '{VirtualSensorName}' created successfully!");
    }

    private void CalculateVirtualSensorValues(VirtualSensor virtualSensor)
    {
        // Handle ChangeTime operations specially
        if (virtualSensor.Operation == "ChangeTime" || virtualSensor.Operation == "ChangeTimeMs")
        {
            CalculateChangeTimeValues(virtualSensor);
            return;
        }

        // Handle MaxChangeTime operations
        if (virtualSensor.Operation == "MaxChangeTime" || virtualSensor.Operation == "MaxChangeTimeMs")
        {
            CalculateMaxChangeTimeValues(virtualSensor);
            return;
        }

        // Standard binary operations
        foreach (var point in LogData)
        {
            double valueA = point.RawData.ContainsKey(virtualSensor.SensorA) ? point.RawData[virtualSensor.SensorA] : 0;
            double valueB = point.RawData.ContainsKey(virtualSensor.SensorB) ? point.RawData[virtualSensor.SensorB] : 0;

            double result = virtualSensor.Operation switch
            {
                "+" => valueA + valueB,
                "-" => valueA - valueB,
                "*" => valueA * valueB,
                "/" => valueB != 0 ? valueA / valueB : 0,
                _ => 0
            };

            point.RawData[virtualSensor.Name] = result;
        }
    }

    private void CalculateChangeTimeValues(VirtualSensor virtualSensor)
    {
        if (LogData.Count == 0) return;

        bool useMilliseconds = virtualSensor.Operation == "ChangeTimeMs";
        double lastValue = double.NaN;
        DateTime lastChangeTime = DateTime.MinValue;

        for (int i = 0; i < LogData.Count; i++)
        {
            var point = LogData[i];
            double currentValue = point.RawData.ContainsKey(virtualSensor.SensorA)
                ? point.RawData[virtualSensor.SensorA]
                : 0;

            // First point or value changed
            if (double.IsNaN(lastValue) || Math.Abs(currentValue - lastValue) > double.Epsilon)
            {
                lastValue = currentValue;
                lastChangeTime = point.DeviceTime;
                point.RawData[virtualSensor.Name] = 0; // Time since change is 0 at the change point
            }
            else
            {
                // Calculate time since last change (progressive)
                var timeSinceChange = point.DeviceTime - lastChangeTime;
                double value = useMilliseconds
                    ? timeSinceChange.TotalMilliseconds
                    : timeSinceChange.TotalSeconds;

                point.RawData[virtualSensor.Name] = value;
            }
        }
    }

    private void CalculateMaxChangeTimeValues(VirtualSensor virtualSensor)
    {
        if (LogData.Count == 0) return;

        bool useMilliseconds = virtualSensor.Operation == "MaxChangeTimeMs";
        double lastValue = double.NaN;
        DateTime lastChangeTime = DateTime.MinValue;
        int lastChangeIndex = 0;

        // First pass: detect all change points and calculate durations
        var changeDurations = new List<(int startIndex, int endIndex, double duration)>();

        for (int i = 0; i < LogData.Count; i++)
        {
            var point = LogData[i];
            double currentValue = point.RawData.ContainsKey(virtualSensor.SensorA)
                ? point.RawData[virtualSensor.SensorA]
                : 0;

            // First point
            if (double.IsNaN(lastValue))
            {
                lastValue = currentValue;
                lastChangeTime = point.DeviceTime;
                lastChangeIndex = i;
            }
            // Value changed
            else if (Math.Abs(currentValue - lastValue) > double.Epsilon)
            {
                // Calculate the duration for the previous segment
                var duration = point.DeviceTime - lastChangeTime;
                double durationValue = useMilliseconds
                    ? duration.TotalMilliseconds
                    : duration.TotalSeconds;

                changeDurations.Add((lastChangeIndex, i - 1, durationValue));

                // Update for next segment
                lastValue = currentValue;
                lastChangeTime = point.DeviceTime;
                lastChangeIndex = i;
            }
        }

        // Add the final segment (from last change to end)
        if (lastChangeIndex < LogData.Count)
        {
            var finalDuration = LogData[LogData.Count - 1].DeviceTime - lastChangeTime;
            double finalDurationValue = useMilliseconds
                ? finalDuration.TotalMilliseconds
                : finalDuration.TotalSeconds;

            changeDurations.Add((lastChangeIndex, LogData.Count - 1, finalDurationValue));
        }

        // Second pass: apply the constant duration values to all points in each segment
        foreach (var (startIndex, endIndex, duration) in changeDurations)
        {
            for (int i = startIndex; i <= endIndex; i++)
            {
                LogData[i].RawData[virtualSensor.Name] = duration;
            }
        }
    }

    private List<LogPoint> ApplySampling(List<LogPoint> allPoints)
    {
        if (allPoints.Count == 0) return allPoints;

        switch (SamplingMode)
        {
            case "Time":
                return ApplyTimeSampling(allPoints, SamplingTimeMs);

            case "Index":
                return ApplyIndexSampling(allPoints, SamplingEveryN);

            case "None":
            default:
                return allPoints;
        }
    }

    private List<LogPoint> ApplyTimeSampling(List<LogPoint> allPoints, int intervalMs)
    {
        if (allPoints.Count == 0) return allPoints;

        var sampledPoints = new List<LogPoint>();
        DateTime? lastSampledTime = null;

        foreach (var point in allPoints)
        {
            if (lastSampledTime == null ||
                (point.DeviceTime - lastSampledTime.Value).TotalMilliseconds >= intervalMs)
            {
                sampledPoints.Add(point);
                lastSampledTime = point.DeviceTime;
            }
        }

        return sampledPoints;
    }

    private List<LogPoint> ApplyIndexSampling(List<LogPoint> allPoints, int everyN)
    {
        if (allPoints.Count == 0 || everyN <= 0) return allPoints;

        var sampledPoints = new List<LogPoint>();

        for (int i = 0; i < allPoints.Count; i += everyN)
        {
            sampledPoints.Add(allPoints[i]);
        }

        if (sampledPoints.Count > 0 && sampledPoints[sampledPoints.Count - 1] != allPoints[allPoints.Count - 1])
        {
            sampledPoints.Add(allPoints[allPoints.Count - 1]);
        }

        return sampledPoints;
    }

    private DateTime ParseDeviceTime(string timeStr)
    {
        if (string.IsNullOrWhiteSpace(timeStr))
            return DateTime.MinValue;

        timeStr = Regex.Replace(timeStr, @"([a-z]{3})\.", "$1", RegexOptions.IgnoreCase);

        var culturePt = new CultureInfo("pt-BR");
        if (DateTime.TryParse(timeStr, culturePt, DateTimeStyles.None, out DateTime dt))
            return dt;

        var match = Regex.Match(timeStr, @"(\d{1,2})-([a-z]{3})-(\d{4})\s+(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d+))?", RegexOptions.IgnoreCase);

        if (match.Success)
        {
            try
            {
                int day = int.Parse(match.Groups[1].Value);
                string monthStr = match.Groups[2].Value.ToLower();
                int year = int.Parse(match.Groups[3].Value);
                int hour = int.Parse(match.Groups[4].Value);
                int minute = int.Parse(match.Groups[5].Value);
                int second = int.Parse(match.Groups[6].Value);
                int millisecond = 0;

                if (match.Groups[7].Success)
                {
                    string msStr = match.Groups[7].Value;
                    if (msStr.Length > 3) msStr = msStr.Substring(0, 3);
                    millisecond = int.Parse(msStr.PadRight(3, '0'));
                }

                if (MonthMap.TryGetValue(monthStr, out int month))
                {
                    return new DateTime(year, month, day, hour, minute, second, millisecond);
                }
            }
            catch
            {
            }
        }

        return DateTime.MinValue;
    }

    // Helper class for JSON serialization
    public class SensorConfiguration
    {
        public string Name { get; set; } = string.Empty;
        public string Color { get; set; } = string.Empty;
    }

    public class LogDataExport
    {
        public List<LogPoint> Data { get; set; } = new();
    }

    public class VirtualSensor
    {
        public string Name { get; set; } = string.Empty;
        public string SensorA { get; set; } = string.Empty;
        public string SensorB { get; set; } = string.Empty;
        public string Operation { get; set; } = "+";
        public bool IsVirtual { get; set; } = true;
    }
}