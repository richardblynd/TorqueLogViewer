@page "/"
@using System.Globalization
@using System.Text
@using System.Text.RegularExpressions
@inject IJSRuntime JS

<div class="layout-container">
    @if (IsDataLoaded)
    {
        <TorqueLogViewer.Components.SensorSidebar 
            AvailableSensors="@AvailableSensors"
            SelectedSensors="@SelectedSensors"
            SensorColorMapping="@SensorColorMapping"
            OnSensorToggle="@HandleSensorToggle"
            CurrentPoint="@CurrentPoint"
            AllLogData="@LogData"
            @bind-IsExpanded="@IsSensorSidebarExpanded" />
    }

    <div class="content-area">
        @if (IsMapVisible)
        {
            <div class="map-area">
                <div id="map" class="map-container"></div>
            </div>
        }

        <div class="chart-area">
            <div class="controls-bar">
                <div class="control-group">
                    <label>Load Log (CSV):</label>
                    <InputFile OnChange="HandleFileSelected" />
                </div>

                @if (!IsDataLoaded)
                {
                    <div class="control-group">
                        <label>Sampling Mode:</label>
                        <select @bind="SamplingMode" class="form-select-small">
                            <option value="None">No Sampling (All Points)</option>
                            <option value="Time">Time Interval</option>
                            <option value="Index">Every N Points</option>
                        </select>
                    </div>

                    @if (SamplingMode == "Time")
                    {
                        <div class="control-group">
                            <label>Interval (ms):</label>
                            <input type="number" @bind="SamplingTimeMs" min="10" max="10000" step="10" class="form-input-small" />
                        </div>
                    }
                    else if (SamplingMode == "Index")
                    {
                        <div class="control-group">
                            <label>Every N points:</label>
                            <input type="number" @bind="SamplingEveryN" min="1" max="1000" step="1" class="form-input-small" />
                        </div>
                    }
                }

                @if (IsDataLoaded)
                {
                    <button class="btn-toggle-map" @onclick="ToggleMapVisibility" title="@(IsMapVisible ? "Hide Map" : "Show Map")">
                        @(IsMapVisible ? "🗺️ Hide Map" : "🗺️ Show Map")
                    </button>

                    <div class="info-badge">
                        <span>📊 @LogData.Count points loaded</span>
                        @if (TotalPointsBeforeSampling > LogData.Count)
                        {
                            <span style="margin-left: 10px; color: #ff9800;">
                                (sampled from @TotalPointsBeforeSampling)
                            </span>
                        }
                    </div>

                    <button class="btn-reset" @onclick="ResetZoom">⟲ Reset Zoom</button>

                    <button class="btn-sync" @onclick="CopySensorsToClipboard" title="Copy selected sensors">
                        📋 Copy Sensors
                    </button>

                    <button class="btn-sync" @onclick="ImportSensorsFromClipboard" title="Import sensors from clipboard">
                        📥 Import Sensors
                    </button>

                    <button class="btn-virtual" @onclick="OpenVirtualSensorModal" title="Create virtual sensor">
                        ➕ Virtual Sensor
                    </button>

                    <button class="btn-export" @onclick="MarkStartPoint" title="Mark start of range">
                        📍 Mark Start
                    </button>

                    <button class="btn-export" @onclick="MarkEndPoint" title="Mark end of range">
                        📍 Mark End
                    </button>

                    <button class="btn-export" @onclick="ExportRangeToClipboard" title="Export range to clipboard">
                        📤 Export Range
                    </button>

                    <div class="control-group">
                        <label>X Axis:</label>
                        <select @onchange="OnXAxisChanged">
                            <option value="DeviceTime">Device Time (Default)</option>
                            <option value="Index">Index (Sequence)</option>
                        </select>
                    </div>
                }
            </div>

            <div class="chart-wrapper">
                <div class="chart-container">
                    <canvas id="logChart"></canvas>
                </div>
            </div>
            
            <div id="scrollbarContainer" class="scrollbar-container" style="display: none;">
                <label class="scrollbar-label">Navigation:</label>
                <input type="range" id="chartScrollbar" class="chart-scrollbar" />
            </div>

            <div class="info-panel">
                @if (CurrentPoint != null)
                {
                    <div>
                        <strong>Selected Point (@CurrentIndex):</strong>
                        Time: @CurrentPoint.DeviceTime.ToString() |
                        Time: @CurrentPoint.DeviceTime.ToString("HH:mm:ss") |
                        Speed: @GetValue(CurrentPoint, "Speed (GPS)(km/h)") km/h |
                        RPM: @GetValue(CurrentPoint, "Engine RPM(rpm)")
                    </div>
                }
                @if (StartIndex >= 0 || EndIndex >= 0)
                {
                    <div style="margin-top: 5px; color: #ff9800;">
                        <strong>Export Range:</strong>
                        @if (StartIndex >= 0)
                        {
                            <span>Start: @StartIndex</span>
                        }
                        @if (EndIndex >= 0)
                        {
                            <span style="margin-left: 10px;">End: @EndIndex</span>
                        }
                        @if (StartIndex >= 0 && EndIndex >= 0)
                        {
                            <span style="margin-left: 10px;">(@(EndIndex - StartIndex + 1) points)</span>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
</div>

@* Virtual Sensor Modal *@
@if (ShowVirtualSensorModal)
{
    <div class="modal-overlay" @onclick="CloseVirtualSensorModal">
        <div class="modal-content" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h3>Create Virtual Sensor</h3>
                <button class="btn-close" @onclick="CloseVirtualSensorModal">✕</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Virtual Sensor Name:</label>
                    <input type="text" @bind="VirtualSensorName" placeholder="e.g., Power Calculation" class="form-input" />
                </div>

                <div class="form-group">
                    <label>First Sensor:</label>
                    <select @bind="VirtualSensorA" class="form-select">
                        <option value="">-- Select Sensor --</option>
                        @foreach (var sensor in AvailableSensors)
                        {
                            <option value="@sensor">@sensor</option>
                        }
                    </select>
                </div>

                <div class="form-group">
                    <label>Operation:</label>
                    <select @bind="VirtualSensorOperation" class="form-select">
                        <option value="+">Addition (+)</option>
                        <option value="-">Subtraction (-)</option>
                        <option value="*">Multiplication (×)</option>
                        <option value="/">Division (÷)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Second Sensor:</label>
                    <select @bind="VirtualSensorB" class="form-select">
                        <option value="">-- Select Sensor --</option>
                        @foreach (var sensor in AvailableSensors)
                        {
                            <option value="@sensor">@sensor</option>
                        }
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" @onclick="CloseVirtualSensorModal">Cancel</button>
                <button class="btn-create" @onclick="CreateVirtualSensor">Create</button>
            </div>
        </div>
    </div>
}

<style>
    /* Basic Styles for Split Layout */
    .layout-container {
        display: flex;
        height: 100%;
        width: 100%;
        overflow: hidden;
    }

    .content-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .map-area {
        flex: 1;
        min-height: 35vh;
        max-height: 35vh;
        width: 100%;
        border-bottom: 2px solid #ccc;
    }

    .map-container {
        width: 100%;
        height: 100%;
        z-index: 1;
    }

    .chart-area {
        flex: 1;
        min-height: 40vh;
        display: flex;
        flex-direction: column;
        background-color: #f8f9fa;
    }

    .controls-bar {
        padding: 10px;
        background: #fff;
        border-bottom: 1px solid #ddd;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        flex-shrink: 0;
    }

    .control-group {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
    }

    .btn-reset, .btn-sync, .btn-toggle-map {
        padding: 5px 10px;
        cursor: pointer;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 0.85rem;
    }

    .btn-reset:hover, .btn-sync:hover, .btn-toggle-map:hover {
        background-color: #45a049;
    }

    .btn-toggle-map {
        background-color: #607d8b;
    }

    .btn-toggle-map:hover {
        background-color: #546e7a;
    }

    .btn-sync {
        background-color: #2196F3;
    }

    .btn-sync:hover {
        background-color: #0b7dda;
    }

    .btn-virtual {
        padding: 5px 10px;
        cursor: pointer;
        background-color: #9c27b0;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 0.85rem;
    }

    .btn-virtual:hover {
        background-color: #7b1fa2;
    }

    .btn-export {
        padding: 5px 10px;
        cursor: pointer;
        background-color: #ff9800;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 0.85rem;
    }

    .btn-export:hover {
        background-color: #e68900;
    }

    .chart-wrapper {
        flex: 1;
        position: relative;
        overflow: hidden;
    }

    .chart-container {
        width: 100%;
        height: 100%;
        position: relative;
        padding: 10px;
        overflow: hidden;
    }

    .info-panel {
        padding: 5px 10px;
        background: #e9ecef;
        font-size: 0.9rem;
        border-top: 1px solid #ddd;
        flex-shrink: 0;
    }

    /* Horizontal scrollbar for chart navigation */
    .scrollbar-container {
        padding: 10px;
        background: #fff;
        border-top: 1px solid #ddd;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-shrink: 0;
    }

    .scrollbar-label {
        font-size: 0.85rem;
        font-weight: 500;
        margin: 0;
        white-space: nowrap;
    }

    .chart-scrollbar {
        flex: 1;
        height: 8px;
        -webkit-appearance: none;
        appearance: none;
        background: #e0e0e0;
        border-radius: 5px;
        outline: none;
        cursor: pointer;
    }

    .chart-scrollbar::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 60px;
        height: 20px;
        background: #4CAF50;
        border-radius: 5px;
        cursor: grab;
        transition: background 0.2s;
    }

    .chart-scrollbar::-webkit-slider-thumb:hover {
        background: #45a049;
    }

    .chart-scrollbar::-webkit-slider-thumb:active {
        cursor: grabbing;
        background: #3d8b40;
    }

    .chart-scrollbar::-moz-range-thumb {
        width: 60px;
        height: 20px;
        background: #4CAF50;
        border-radius: 5px;
        border: none;
        cursor: grab;
        transition: background 0.2s;
    }

    .chart-scrollbar::-moz-range-thumb:hover {
        background: #45a049;
    }

    .chart-scrollbar::-moz-range-thumb:active {
        cursor: grabbing;
        background: #3d8b40;
    }

    /* Modal Styles */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
    }

    .modal-content {
        background: white;
        border-radius: 8px;
        width: 90%;
        max-width: 500px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
        padding: 20px;
        border-bottom: 1px solid #ddd;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .modal-header h3 {
        margin: 0;
        font-size: 1.2rem;
    }

    .btn-close {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #666;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .btn-close:hover {
        color: #000;
    }

    .modal-body {
        padding: 20px;
    }

    .form-group {
        margin-bottom: 15px;
    }

    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        font-size: 0.9rem;
    }

    .form-input, .form-select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.9rem;
    }

    .form-input:focus, .form-select:focus {
        outline: none;
        border-color: #4CAF50;
    }

    .modal-footer {
        padding: 15px 20px;
        border-top: 1px solid #ddd;
        display: flex;
        justify-content: flex-end;
        gap: 10px;
    }

    .btn-cancel, .btn-create {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
    }

    .btn-cancel {
        background-color: #f44336;
        color: white;
    }

    .btn-cancel:hover {
        background-color: #d32f2f;
    }

    .btn-create {
        background-color: #4CAF50;
        color: white;
    }

    .btn-create:hover {
        background-color: #45a049;
    }

    /* Additional Styles for Sampling Controls */
    .form-select-small, .form-input-small {
        padding: 5px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 0.85rem;
        background: white;
    }

    .form-input-small {
        width: 80px;
    }

    .info-badge {
        padding: 5px 10px;
        background-color: #e3f2fd;
        border-radius: 4px;
        font-size: 0.85rem;
        font-weight: 500;
        color: #1976d2;
        display: flex;
        align-items: center;
    }
</style>

@code {
    private bool IsDataLoaded = false;
    private List<LogPoint> LogData = new();
    private List<string> AvailableSensors = new();
    private HashSet<string> SelectedSensors = new();
    private bool IsSensorSidebarExpanded = true;
    private bool IsMapVisible = true;

    // Sampling configuration
    private string SamplingMode = "None"; // None, Time, Index
    private int SamplingTimeMs = 1000; // Sample every 100ms by default
    private int SamplingEveryN = 10; // Sample every 10 points by default
    private int TotalPointsBeforeSampling = 0;

    // Current state
    private LogPoint? CurrentPoint;
    private int CurrentIndex = -1;
    private string XAxisMode = "DeviceTime";

    // Export range tracking
    private int StartIndex = -1;
    private int EndIndex = -1;

    // Color mapping for sensors
    private static readonly string[] ChartColors = { "#FF5733", "#33FF57", "#3357FF", "#FF33F6", "#33FFF6", "#F3FF33", "#FF8C33" };
    private Dictionary<string, string> SensorColorMapping = new();

    // Marked range points
    private LogPoint? StartPoint = null;
    private LogPoint? EndPoint = null;

    // Virtual sensor state
    private bool ShowVirtualSensorModal = false;
    private string VirtualSensorName = string.Empty;
    private string VirtualSensorA = string.Empty;
    private string VirtualSensorB = string.Empty;
    private string VirtualSensorOperation = "+";
    private List<VirtualSensor> VirtualSensors = new();

    // Mapping of Portuguese month abbreviations to numbers
    private static readonly Dictionary<string, int> MonthMap = new(StringComparer.OrdinalIgnoreCase)
    {
        { "jan", 1 }, { "fev", 2 }, { "mar", 3 }, { "abr", 4 },
        { "mai", 5 }, { "jun", 6 }, { "jul", 7 }, { "ago", 8 },
        { "set", 9 }, { "out", 10 }, { "nov", 11 }, { "dez", 12 }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("torqueApp.initMap", DotNetObjectReference.Create(this));
            await JS.InvokeVoidAsync("torqueApp.initChart");
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss}] === START FILE LOADING ===");

        var file = e.File;
        if (file == null) return;

        // Show loading indicator
        await JS.InvokeVoidAsync("torqueApp.showLoading", true);
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 0, "Starting file load...");

        try
        {
            var streamStartTime = DateTime.Now;
            Console.WriteLine($"[{streamStartTime:HH:mm:ss}] Starting file stream read (size: {file.Size} bytes)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 5, "Opening file stream...");

            // Size limit increased to 50MB for larger files
            using var stream = file.OpenReadStream(50 * 1024 * 1024);
            using var reader = new StreamReader(stream);

            var readStartTime = DateTime.Now;
            Console.WriteLine($"[{readStartTime:HH:mm:ss}] Reading file content");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 10, "Reading file content...");

            var content = await reader.ReadToEndAsync();

            var readEndTime = DateTime.Now;
            var readDuration = (readEndTime - readStartTime).TotalMilliseconds;
            Console.WriteLine($"[{readEndTime:HH:mm:ss}] File read completed (duration: {readDuration:F2}ms, size: {content.Length} characters)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 20, "File read complete");

            var parseStartTime = DateTime.Now;
            Console.WriteLine($"[{parseStartTime:HH:mm:ss}] Starting CSV parse");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 25, "Starting CSV parse...");

            // Parse on the UI thread with progress updates
            await ParseCSVAsync(content);

            var parseEndTime = DateTime.Now;
            var parseDuration = (parseEndTime - parseStartTime).TotalMilliseconds;
            Console.WriteLine($"[{parseEndTime:HH:mm:ss}] CSV parse completed (duration: {parseDuration:F2}ms)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 95, "Parse complete");

            var uiStartTime = DateTime.Now;
            Console.WriteLine($"[{uiStartTime:HH:mm:ss}] Updating UI");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 98, "Updating UI...");

            // Update UI
            StateHasChanged();

            var uiEndTime = DateTime.Now;
            var uiDuration = (uiEndTime - uiStartTime).TotalMilliseconds;
            Console.WriteLine($"[{uiEndTime:HH:mm:ss}] UI updated (duration: {uiDuration:F2}ms)");
            await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 100, "Complete!");

            // Longer delay to show 100% before closing
            await Task.Delay(500);
        }
        finally
        {
            await JS.InvokeVoidAsync("torqueApp.showLoading", false);

            var endTime = DateTime.Now;
            var totalDuration = (endTime - startTime).TotalMilliseconds;
            Console.WriteLine($"[{endTime:HH:mm:ss}] === END FILE LOADING ===");
            Console.WriteLine($"[{endTime:HH:mm:ss}] TOTAL TIME: {totalDuration:F2}ms ({totalDuration / 1000:F2}s)");
        }
    }

    private async Task ParseCSVAsync(string csvContent)
    {
        var parseStartTime = DateTime.Now;
        Console.WriteLine($"[{parseStartTime:HH:mm:ss}] ParseCSV: Starting");

        LogData.Clear();
        AvailableSensors.Clear();
        SelectedSensors.Clear();
        VirtualSensors.Clear();
        TotalPointsBeforeSampling = 0;

        var splitStartTime = DateTime.Now;
        Console.WriteLine($"[{splitStartTime:HH:mm:ss}] ParseCSV: Splitting lines");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 30, "Splitting lines...");
        await Task.Yield(); // Allow UI to update

        var lines = csvContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);

        var splitEndTime = DateTime.Now;
        var splitDuration = (splitEndTime - splitStartTime).TotalMilliseconds;
        Console.WriteLine($"[{splitEndTime:HH:mm:ss}] ParseCSV: Lines split (duration: {splitDuration:F2}ms, total: {lines.Length} lines)");

        if (lines.Length < 2) return;

        var headerStartTime = DateTime.Now;
        Console.WriteLine($"[{headerStartTime:HH:mm:ss}] ParseCSV: Parsing headers");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 35, "Parsing headers...");
        await Task.Yield();

        // Parse headers - optimized
        var headers = ParseCsvLineOptimized(lines[0]);
        for (int i = 0; i < headers.Length; i++) 
        {
            headers[i] = headers[i].Trim().Trim('"');
        }

        var headerEndTime = DateTime.Now;
        var headerDuration = (headerEndTime - headerStartTime).TotalMilliseconds;
        Console.WriteLine($"[{headerEndTime:HH:mm:ss}] ParseCSV: Headers parsed (duration: {headerDuration:F2}ms, total: {headers.Length} columns)");

        var timeDetectionStartTime = DateTime.Now;
        Console.WriteLine($"[{timeDetectionStartTime:HH:mm:ss}] ParseCSV: Detecting time column");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 38, "Detecting time column...");
        await Task.Yield();

        // Detect time column
        int timeColumnIndex = -1;
        if (lines.Length > 1)
        {
            var firstDataLine = ParseCsvLineOptimized(lines[1]);

            for (int i = 0; i < Math.Min(2, firstDataLine.Length); i++)
            {
                firstDataLine[i] = firstDataLine[i].Trim().Trim('"');
            }

            if (firstDataLine.Length > 0 && Regex.IsMatch(firstDataLine[0].Trim(), @"^\d{1,2}:\d{1,2}:\d{1,2}"))
            {
                timeColumnIndex = 0;
            }
            else if (firstDataLine.Length > 1 && (firstDataLine[1].Contains("-") || Regex.IsMatch(firstDataLine[1].Trim(), @"\d{1,2}:\d{1,2}:\d{1,2}")))
            {
                timeColumnIndex = 1;
            }
        }

        if (timeColumnIndex == -1)
        {
            timeColumnIndex = 1;
        }

        var timeDetectionEndTime = DateTime.Now;
        var timeDetectionDuration = (timeDetectionEndTime - timeDetectionStartTime).TotalMilliseconds;
        Console.WriteLine($"[{timeDetectionEndTime:HH:mm:ss}] ParseCSV: Time column detected (duration: {timeDetectionDuration:F2}ms, index: {timeColumnIndex})");

        var sensorIndexStartTime = DateTime.Now;
        Console.WriteLine($"[{sensorIndexStartTime:HH:mm:ss}] ParseCSV: Identifying sensors");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 40, "Identifying sensors...");
        await Task.Yield();

        // Pre-compute sensor indices for faster access
        var ignoreCols = new HashSet<string> { "GPS Time", "Device Time", "Longtitude", "Longitude", "Latitude" };
        var sensorIndices = new List<(int index, string name)>();

        for (int i = 0; i < headers.Length; i++)
        {
            if (!ignoreCols.Contains(headers[i]))
            {
                AvailableSensors.Add(headers[i]);
                sensorIndices.Add((i, headers[i]));
            }
        }

        var sensorIndexEndTime = DateTime.Now;
        var sensorIndexDuration = (sensorIndexEndTime - sensorIndexStartTime).TotalMilliseconds;
        Console.WriteLine($"[{sensorIndexEndTime:HH:mm:ss}] ParseCSV: Sensors identified (duration: {sensorIndexDuration:F2}ms, total: {AvailableSensors.Count} sensors)");

        var columnIndexStartTime = DateTime.Now;
        Console.WriteLine($"[{columnIndexStartTime:HH:mm:ss}] ParseCSV: Calculating column indices");

        // Pre-calculate column indices
        int longitudeIndex = Array.IndexOf(headers, "Longitude");
        if (longitudeIndex < 0)
        {
            longitudeIndex = Array.IndexOf(headers, "Longtitude");
        }
        int latitudeIndex = Array.IndexOf(headers, "Latitude");

        // Pre-allocate list with estimated capacity
        var allPoints = new List<LogPoint>(lines.Length - 1);

        var columnIndexEndTime = DateTime.Now;
        var columnIndexDuration = (columnIndexEndTime - columnIndexStartTime).TotalMilliseconds;
        Console.WriteLine($"[{columnIndexEndTime:HH:mm:ss}] ParseCSV: Indices calculated (duration: {columnIndexDuration:F2}ms)");

        var dataParseStartTime = DateTime.Now;
        Console.WriteLine($"[{dataParseStartTime:HH:mm:ss}] ParseCSV: Parsing data points");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 45, $"Parsing data points (0/{lines.Length - 1})...");
        await Task.Yield();

        // Parse data points with optimized loop
        int progressUpdateInterval = Math.Max((lines.Length - 1) / 20, 100); // Update progress every ~5% or every 100 lines
        
        for (int i = 1; i < lines.Length; i++)
        {
            var cols = ParseCsvLineOptimized(lines[i]);
            if (cols.Length != headers.Length) continue;

            // Clean quotes only where needed
            for (int j = 0; j < cols.Length; j++)
            {
                var span = cols[j].AsSpan().Trim();
                if (span.Length > 0 && span[0] == '"')
                {
                    cols[j] = span.Trim('"').ToString();
                }
                else if (span.Length != cols[j].Length)
                {
                    cols[j] = span.ToString();
                }
            }

            var point = new LogPoint
            {
                RawData = new Dictionary<string, double>(sensorIndices.Count)
            };

            // Parse Time
            if (timeColumnIndex >= 0 && timeColumnIndex < cols.Length)
            {
                point.DeviceTime = ParseDeviceTimeOptimized(cols[timeColumnIndex]);
            }

            // Parse Lat/Lon
            if (longitudeIndex >= 0 && longitudeIndex < cols.Length)
                point.Longitude = ParseDoubleOptimized(cols[longitudeIndex]);
            if (latitudeIndex >= 0 && latitudeIndex < cols.Length)
                point.Latitude = ParseDoubleOptimized(cols[latitudeIndex]);

            // Parse Sensors using pre-computed indices
            foreach (var (index, name) in sensorIndices)
            {
                if (index < cols.Length)
                {
                    point.RawData[name] = ParseDoubleOptimized(cols[index]);
                }
            }

            allPoints.Add(point);
            
            // Update progress periodically
            if (i % progressUpdateInterval == 0)
            {
                int progressPercentage = 45 + (int)((i / (double)(lines.Length - 1)) * 35); // 45-80%
                int pointsParsed = i;
                await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", progressPercentage, 
                    $"Parsing data points ({pointsParsed:N0}/{lines.Length - 1:N0})...");
                await Task.Yield(); // Allow UI to update
            }
        }

        var dataParseEndTime = DateTime.Now;
        var dataParseDuration = (dataParseEndTime - dataParseStartTime).TotalMilliseconds;
        Console.WriteLine($"[{dataParseEndTime:HH:mm:ss}] ParseCSV: Data points parsed (duration: {dataParseDuration:F2}ms, total: {allPoints.Count} points)");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 80, "Data parsing complete");
        await Task.Yield();

        TotalPointsBeforeSampling = allPoints.Count;

        var samplingStartTime = DateTime.Now;
        Console.WriteLine($"[{samplingStartTime:HH:mm:ss}] ParseCSV: Applying sampling (mode: {SamplingMode})");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 82, $"Applying sampling ({SamplingMode})...");
        await Task.Yield();

        // Apply sampling
        LogData = ApplySampling(allPoints);

        var samplingEndTime = DateTime.Now;
        var samplingDuration = (samplingEndTime - samplingStartTime).TotalMilliseconds;
        Console.WriteLine($"[{samplingEndTime:HH:mm:ss}] ParseCSV: Sampling applied (duration: {samplingDuration:F2}ms, points after sampling: {LogData.Count})");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 85, "Sampling complete");
        await Task.Yield();

        IsDataLoaded = true;
        
        var visualizationStartTime = DateTime.Now;
        Console.WriteLine($"[{visualizationStartTime:HH:mm:ss}] ParseCSV: Updating visualization");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 88, "Updating map and chart...");
        await Task.Yield();

        UpdateVisualization();
        
        var visualizationEndTime = DateTime.Now;
        var visualizationDuration = (visualizationEndTime - visualizationStartTime).TotalMilliseconds;
        Console.WriteLine($"[{visualizationEndTime:HH:mm:ss}] ParseCSV: Visualization updated (duration: {visualizationDuration:F2}ms)");
        await JS.InvokeVoidAsync("torqueApp.updateLoadingProgress", 92, "Visualization complete");

        var parseEndTime = DateTime.Now;
        var totalParseDuration = (parseEndTime - parseStartTime).TotalMilliseconds;
        Console.WriteLine($"[{parseEndTime:HH:mm:ss}] ParseCSV: Completed (total duration: {totalParseDuration:F2}ms)");
    }

    private string[] ParseCsvLineOptimized(string line)
    {
        // Fast path for lines without quotes
        if (line.IndexOf('"') < 0)
        {
            return line.Split(',');
        }

        // Optimized parsing for quoted fields
        var result = new List<string>(50);
        var currentField = new StringBuilder(32);
        bool insideQuotes = false;

        for (int i = 0; i < line.Length; i++)
        {
            char c = line[i];

            if (c == '"')
            {
                if (insideQuotes && i + 1 < line.Length && line[i + 1] == '"')
                {
                    currentField.Append('"');
                    i++;
                }
                else
                {
                    insideQuotes = !insideQuotes;
                }
            }
            else if (c == ',' && !insideQuotes)
            {
                result.Add(currentField.ToString());
                currentField.Clear();
            }
            else
            {
                currentField.Append(c);
            }
        }

        result.Add(currentField.ToString());
        return result.ToArray();
    }

    private DateTime ParseDeviceTimeOptimized(string timeStr)
    {
        if (string.IsNullOrWhiteSpace(timeStr))
            return DateTime.MinValue;

        var span = timeStr.AsSpan().Trim();

        // Fast path: Simple time format HH:mm:ss.fff
        if (span.Length >= 8 && span.Length <= 12 && span.IndexOf('-') < 0)
        {
            if (TryParseSimpleTime(span, out DateTime simpleTime))
                return simpleTime;
        }

        // Fallback to original parsing
        return ParseDeviceTime(timeStr);
    }

    private bool TryParseSimpleTime(ReadOnlySpan<char> span, out DateTime result)
    {
        result = DateTime.MinValue;

        int firstColon = span.IndexOf(':');
        if (firstColon < 0) return false;

        int secondColon = span.Slice(firstColon + 1).IndexOf(':');
        if (secondColon < 0) return false;
        secondColon += firstColon + 1;

        if (!int.TryParse(span.Slice(0, firstColon), out int hour)) return false;
        if (!int.TryParse(span.Slice(firstColon + 1, secondColon - firstColon - 1), out int minute)) return false;

        int dotIndex = span.Slice(secondColon).IndexOf('.');
        int secondEnd = dotIndex >= 0 ? secondColon + dotIndex : span.Length;
        
        if (!int.TryParse(span.Slice(secondColon + 1, secondEnd - secondColon - 1), out int second)) return false;

        int millisecond = 0;
        if (dotIndex >= 0 && secondEnd + 1 < span.Length)
        {
            var msSpan = span.Slice(secondEnd + 1);
            if (msSpan.Length > 3) msSpan = msSpan.Slice(0, 3);
            
            if (int.TryParse(msSpan, out int ms))
            {
                millisecond = msSpan.Length switch
                {
                    1 => ms * 100,
                    2 => ms * 10,
                    _ => ms
                };
            }
        }

        try
        {
            var today = DateTime.Today;
            result = new DateTime(today.Year, today.Month, today.Day, hour, minute, second, millisecond);
            return true;
        }
        catch
        {
            return false;
        }
    }

    private double ParseDoubleOptimized(string val)
    {
        if (string.IsNullOrEmpty(val)) return 0;
        
        var span = val.AsSpan().Trim();
        if (span.IsEmpty || (span.Length == 1 && span[0] == '-')) return 0;

        if (double.TryParse(span, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out double result))
            return result;
            
        return 0;
    }

    private void UpdateVisualization()
    {
        if (!IsDataLoaded) return;

        // 1. Update Map (Route)
        // Filter points with valid lat/lon (different from 0 or null if possible)
        var route = LogData
            .Where(p => p.Latitude != 0 && p.Longitude != 0)
            .Select(p => new[] { p.Latitude, p.Longitude })
            .ToList();

        JS.InvokeVoidAsync("torqueApp.drawRoute", route);

        // 2. Update Chart
        UpdateChartData();
    }

    private void UpdateChartData()
    {
        if (LogData.Count == 0) return;

        // Pre-allocate arrays
        string[] labels = new string[LogData.Count];
        
        if (XAxisMode == "DeviceTime")
        {
            for (int i = 0; i < LogData.Count; i++)
            {
                labels[i] = LogData[i].DeviceTime.ToString("HH:mm:ss");
            }
        }
        else
        {
            for (int i = 0; i < LogData.Count; i++)
            {
                labels[i] = i.ToString();
            }
        }

        var datasets = new List<object>(SelectedSensors.Count);
        int colorIdx = 0;

        foreach (var sensor in SelectedSensors)
        {
            if (!SensorColorMapping.ContainsKey(sensor))
            {
                SensorColorMapping[sensor] = ChartColors[colorIdx % ChartColors.Length];
            }

            // Pre-allocate array
            var rawData = new double[LogData.Count];
            
            for (int i = 0; i < LogData.Count; i++)
            {
                rawData[i] = LogData[i].RawData.TryGetValue(sensor, out double value) ? value : 0;
            }

            // Optimized min/max
            double min = double.MaxValue;
            double max = double.MinValue;
            
            foreach (var v in rawData)
            {
                if (v < min) min = v;
                if (v > max) max = v;
            }

            double range = max - min;
            var normalizedData = new double[rawData.Length];

            if (range == 0)
            {
                Array.Fill(normalizedData, 0.5);
            }
            else
            {
                for (int i = 0; i < rawData.Length; i++)
                {
                    normalizedData[i] = (rawData[i] - min) / range;
                }
            }

            datasets.Add(new
            {
                label = sensor,
                data = normalizedData,
                originalData = rawData,
                borderColor = SensorColorMapping[sensor],
                backgroundColor = "transparent",
                borderWidth = 2,
                pointRadius = 0,
                pointHoverRadius = 4,
                tension = 0.1
            });
            
            colorIdx++;
        }

        JS.InvokeVoidAsync("torqueApp.updateChart", labels, datasets);
    }

    private void ToggleSensor(string sensor, bool isChecked)
    {
        if (isChecked) SelectedSensors.Add(sensor);
        else SelectedSensors.Remove(sensor);
        UpdateChartData();
    }

    private void HandleSensorToggle((string sensor, bool isSelected) args)
    {
        if (args.isSelected)
        {
            SelectedSensors.Add(args.sensor);
        }
        else
        {
            SelectedSensors.Remove(args.sensor);
        }
        UpdateChartData();
        StateHasChanged();
    }

    private void ToggleMapVisibility()
    {
        IsMapVisible = !IsMapVisible;
        StateHasChanged();
    }

    private void OnXAxisChanged(ChangeEventArgs e)
    {
        XAxisMode = e.Value?.ToString() ?? "DeviceTime";
        UpdateChartData();
    }

    // Called by JS when the map is clicked
    [JSInvokable]
    public void OnMapClick(double lat, double lng)
    {
        // Find the closest point in the list
        // (This is a simple linear search, for giant logs using KD-Tree would be better, but C# WASM handles ~10k points well)
        var closest = LogData
            .Select((p, index) => new { Point = p, Index = index, Dist = Math.Pow(p.Latitude - lat, 2) + Math.Pow(p.Longitude - lng, 2) })
            .OrderBy(x => x.Dist)
            .FirstOrDefault();

        if (closest != null)
        {
            SelectPoint(closest.Index);
        }
    }

    // Called by JS when the chart is clicked
    [JSInvokable]
    public void OnChartClick(int index)
    {
        SelectPoint(index);
    }

    private void SelectPoint(int index)
    {
        if (index < 0 || index >= LogData.Count) return;

        CurrentIndex = index;
        CurrentPoint = LogData[index];
        StateHasChanged();

        // 1. Update visual on map
        JS.InvokeVoidAsync("torqueApp.highlightPointOnMap", CurrentPoint.Latitude, CurrentPoint.Longitude);

        // 2. Update visual on chart
        JS.InvokeVoidAsync("torqueApp.highlightPointOnChart", index);
    }

    private string GetValue(LogPoint p, string key)
    {
        if (p.RawData.ContainsKey(key)) return p.RawData[key].ToString("F2");
        return "-";
    }

    // Internal Model Class
    public class LogPoint
    {
        public DateTime DeviceTime { get; set; }
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public Dictionary<string, double> RawData { get; set; } = new();
    }

    // Method invoked by JavaScript when pressing Left (-1) or Right (1) arrow keys
    [JSInvokable]
    public void MoveSelection(int direction)
    {
        if (!IsDataLoaded || LogData.Count == 0) return;

        // Calculate the new index
        int newIndex = CurrentIndex + direction;

        // Safety limits
        if (newIndex < 0) newIndex = 0;
        if (newIndex >= LogData.Count) newIndex = LogData.Count - 1;

        // If it changed, select
        if (newIndex != CurrentIndex)
        {
            SelectPoint(newIndex);
        }
    }

    private async Task ResetZoom()
    {
        await JS.InvokeVoidAsync("torqueApp.resetChartZoom");
    }

    private async Task CopySensorsToClipboard()
    {
        if (!IsDataLoaded || SelectedSensors.Count == 0)
        {
            await JS.InvokeVoidAsync("alert", "No sensors selected to copy.");
            return;
        }

        // Create sensor configuration object
        var sensorConfig = SelectedSensors.Select(sensor => new
        {
            Name = sensor,
            Color = SensorColorMapping.ContainsKey(sensor) ? SensorColorMapping[sensor] : ChartColors[0]
        }).ToList();

        // Serialize to JSON
        var json = System.Text.Json.JsonSerializer.Serialize(sensorConfig, new System.Text.Json.JsonSerializerOptions 
        { 
            WriteIndented = true 
        });

        // Copy to clipboard via JavaScript
        await JS.InvokeVoidAsync("torqueApp.copyToClipboard", json);
    }

    private async Task ImportSensorsFromClipboard()
    {
        if (!IsDataLoaded)
        {
            await JS.InvokeVoidAsync("alert", "Please load a CSV file first.");
            return;
        }

        try
        {
            // Read from clipboard via JavaScript
            var json = await JS.InvokeAsync<string>("torqueApp.readFromClipboard");
            
            if (string.IsNullOrWhiteSpace(json))
            {
                await JS.InvokeVoidAsync("alert", "Clipboard is empty.");
                return;
            }

            // Deserialize JSON
            var sensorConfig = System.Text.Json.JsonSerializer.Deserialize<List<SensorConfiguration>>(json);
            
            if (sensorConfig == null || sensorConfig.Count == 0)
            {
                await JS.InvokeVoidAsync("alert", "Invalid data format.");
                return;
            }

            // Clear current selection
            SelectedSensors.Clear();
            
            // Apply imported sensors and colors
            foreach (var config in sensorConfig)
            {
                // Only add if the sensor exists in the current log
                if (AvailableSensors.Contains(config.Name))
                {
                    SelectedSensors.Add(config.Name);
                    SensorColorMapping[config.Name] = config.Color;
                }
            }

            // Update the visualization
            UpdateChartData();
            StateHasChanged();
            
            await JS.InvokeVoidAsync("alert", $"{SelectedSensors.Count} sensors imported successfully!");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", $"Error importing: {ex.Message}");
        }
    }

    private void MarkStartPoint()
    {
        if (CurrentIndex < 0)
        {
            JS.InvokeVoidAsync("alert", "Please select a point on the chart first.");
            return;
        }

        StartIndex = CurrentIndex;
        
        // Clear end if it's before start
        if (EndIndex >= 0 && EndIndex < StartIndex)
        {
            EndIndex = -1;
        }
        
        StateHasChanged();
    }

    private void MarkEndPoint()
    {
        if (CurrentIndex < 0)
        {
            JS.InvokeVoidAsync("alert", "Please select a point on the chart first.");
            return;
        }

        if (StartIndex < 0)
        {
            JS.InvokeVoidAsync("alert", "Please mark the start point first.");
            return;
        }

        if (CurrentIndex < StartIndex)
        {
            JS.InvokeVoidAsync("alert", "End point must be after start point.");
            return;
        }

        EndIndex = CurrentIndex;
        StateHasChanged();
    }

    private async Task ExportRangeToClipboard()
    {
        if (!IsDataLoaded)
        {
            await JS.InvokeVoidAsync("alert", "No data loaded.");
            return;
        }

        if (StartIndex < 0 || EndIndex < 0)
        {
            await JS.InvokeVoidAsync("alert", "Please mark both start and end points first.");
            return;
        }

        if (StartIndex > EndIndex)
        {
            await JS.InvokeVoidAsync("alert", "Invalid range: start point is after end point.");
            return;
        }

        try
        {
            // Extract the range of data
            var rangeData = LogData.Skip(StartIndex).Take(EndIndex - StartIndex + 1).ToList();

            // Create export object
            var exportData = new LogDataExport
            {
                Data = rangeData
            };

            // Serialize to JSON
            var json = System.Text.Json.JsonSerializer.Serialize(exportData, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = true
            });

            // Copy to clipboard
            await JS.InvokeVoidAsync("torqueApp.copyToClipboard", json);

            await JS.InvokeVoidAsync("alert", $"Exported {rangeData.Count} data points to clipboard!");
        }
        catch (Exception ex)
        {
            await JS.InvokeVoidAsync("alert", $"Error exporting: {ex.Message}");
        }
    }

    private void OpenVirtualSensorModal()
    {
        // Reset form fields
        VirtualSensorName = string.Empty;
        VirtualSensorA = string.Empty;
        VirtualSensorB = string.Empty;
        VirtualSensorOperation = "+";
        ShowVirtualSensorModal = true;
    }

    private void CloseVirtualSensorModal()
    {
        ShowVirtualSensorModal = false;
    }

    private async Task CreateVirtualSensor()
    {
        // Validation
        if (string.IsNullOrWhiteSpace(VirtualSensorName))
        {
            await JS.InvokeVoidAsync("alert", "Please enter a name for the virtual sensor.");
            return;
        }

        if (string.IsNullOrWhiteSpace(VirtualSensorA) || string.IsNullOrWhiteSpace(VirtualSensorB))
        {
            await JS.InvokeVoidAsync("alert", "Please select both sensors.");
            return;
        }

        if (VirtualSensorA == VirtualSensorB)
        {
            await JS.InvokeVoidAsync("alert", "Please select two different sensors.");
            return;
        }

        // Check if virtual sensor name already exists
        if (AvailableSensors.Contains(VirtualSensorName) || VirtualSensors.Any(vs => vs.Name == VirtualSensorName))
        {
            await JS.InvokeVoidAsync("alert", "A sensor with this name exists. Please choose a different name.");
            return;
        }

        // Create the virtual sensor
        var virtualSensor = new VirtualSensor
        {
            Name = VirtualSensorName,
            SensorA = VirtualSensorA,
            SensorB = VirtualSensorB,
            Operation = VirtualSensorOperation,
            IsVirtual = true
        };

        VirtualSensors.Add(virtualSensor);

        // Calculate values for all log points
        CalculateVirtualSensorValues(virtualSensor);

        // Add to available sensors list
        AvailableSensors.Add(VirtualSensorName);

        // Automatically select the new virtual sensor
        SelectedSensors.Add(VirtualSensorName);

        // Close modal
        CloseVirtualSensorModal();

        // Update chart
        UpdateChartData();
        StateHasChanged();

        await JS.InvokeVoidAsync("alert", $"Virtual sensor '{VirtualSensorName}' created successfully!");
    }

    private void CalculateVirtualSensorValues(VirtualSensor virtualSensor)
    {
        foreach (var point in LogData)
        {
            double valueA = point.RawData.ContainsKey(virtualSensor.SensorA) ? point.RawData[virtualSensor.SensorA] : 0;
            double valueB = point.RawData.ContainsKey(virtualSensor.SensorB) ? point.RawData[virtualSensor.SensorB] : 0;

            double result = virtualSensor.Operation switch
            {
                "+" => valueA + valueB,
                "-" => valueA - valueB,
                "*" => valueA * valueB,
                "/" => valueB != 0 ? valueA / valueB : 0,
                _ => 0
            };

            point.RawData[virtualSensor.Name] = result;
        }
    }

    private List<LogPoint> ApplySampling(List<LogPoint> allPoints)
    {
        if (allPoints.Count == 0) return allPoints;

        switch (SamplingMode)
        {
            case "Time":
                return ApplyTimeSampling(allPoints, SamplingTimeMs);
            
            case "Index":
                return ApplyIndexSampling(allPoints, SamplingEveryN);
            
            case "None":
            default:
                return allPoints;
        }
    }

    private List<LogPoint> ApplyTimeSampling(List<LogPoint> allPoints, int intervalMs)
    {
        if (allPoints.Count == 0) return allPoints;

        var sampledPoints = new List<LogPoint>();
        DateTime? lastSampledTime = null;

        foreach (var point in allPoints)
        {
            if (lastSampledTime == null || 
                (point.DeviceTime - lastSampledTime.Value).TotalMilliseconds >= intervalMs)
            {
                sampledPoints.Add(point);
                lastSampledTime = point.DeviceTime;
            }
        }

        return sampledPoints;
    }

    private List<LogPoint> ApplyIndexSampling(List<LogPoint> allPoints, int everyN)
    {
        if (allPoints.Count == 0 || everyN <= 0) return allPoints;

        var sampledPoints = new List<LogPoint>();
        
        for (int i = 0; i < allPoints.Count; i += everyN)
        {
            sampledPoints.Add(allPoints[i]);
        }

        if (sampledPoints.Count > 0 && sampledPoints[sampledPoints.Count - 1] != allPoints[allPoints.Count - 1])
        {
            sampledPoints.Add(allPoints[allPoints.Count - 1]);
        }

        return sampledPoints;
    }

    private DateTime ParseDeviceTime(string timeStr)
    {
        if (string.IsNullOrWhiteSpace(timeStr))
            return DateTime.MinValue;

        var simpleTimeMatch = Regex.Match(timeStr.Trim(), @"^(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d+))?$");
        if (simpleTimeMatch.Success)
        {
            try
            {
                int hour = int.Parse(simpleTimeMatch.Groups[1].Value);
                int minute = int.Parse(simpleTimeMatch.Groups[2].Value);
                int second = int.Parse(simpleTimeMatch.Groups[3].Value);
                int millisecond = 0;

                if (simpleTimeMatch.Groups[4].Success)
                {
                    string msStr = simpleTimeMatch.Groups[4].Value;
                    if (msStr.Length > 3) msStr = msStr.Substring(0, 3);
                    millisecond = int.Parse(msStr.PadRight(3, '0'));
                }

                var today = DateTime.Today;
                return new DateTime(today.Year, today.Month, today.Day, hour, minute, second, millisecond);
            }
            catch
            {
            }
        }

        timeStr = Regex.Replace(timeStr, @"([a-z]{3})\.", "$1", RegexOptions.IgnoreCase);

        var culturePt = new CultureInfo("pt-BR");
        if (DateTime.TryParse(timeStr, culturePt, DateTimeStyles.None, out DateTime dt))
            return dt;

        var match = Regex.Match(timeStr, @"(\d{1,2})-([a-z]{3})-(\d{4})\s+(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d+))?", RegexOptions.IgnoreCase);
        
        if (match.Success)
        {
            try
            {
                int day = int.Parse(match.Groups[1].Value);
                string monthStr = match.Groups[2].Value.ToLower();
                int year = int.Parse(match.Groups[3].Value);
                int hour = int.Parse(match.Groups[4].Value);
                int minute = int.Parse(match.Groups[5].Value);
                int second = int.Parse(match.Groups[6].Value);
                int millisecond = 0;

                if (match.Groups[7].Success)
                {
                    string msStr = match.Groups[7].Value;
                    if (msStr.Length > 3) msStr = msStr.Substring(0, 3);
                    millisecond = int.Parse(msStr.PadRight(3, '0'));
                }

                if (MonthMap.TryGetValue(monthStr, out int month))
                {
                    return new DateTime(year, month, day, hour, minute, second, millisecond);
                }
            }
            catch
            {
            }
        }

        return DateTime.MinValue;
    }

    // Helper class for JSON serialization
    public class SensorConfiguration
    {
        public string Name { get; set; } = string.Empty;
        public string Color { get; set; } = string.Empty;
    }

    public class LogDataExport
    {
        public List<LogPoint> Data { get; set; } = new();
    }

    public class VirtualSensor
    {
        public string Name { get; set; } = string.Empty;
        public string SensorA { get; set; } = string.Empty;
        public string SensorB { get; set; } = string.Empty;
        public string Operation { get; set; } = "+";
        public bool IsVirtual { get; set; } = true;
    }
}