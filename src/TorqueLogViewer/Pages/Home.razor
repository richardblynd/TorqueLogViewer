@page "/"
@using System.Globalization
@using System.Text.RegularExpressions
@inject IJSRuntime JS

<div class="layout-container">
    <div id="map" class="map-container"></div>

    <div class="chart-area">
        <div class="controls-bar">
            <div class="control-group">
                <label>Load Log (CSV):</label>
                <InputFile OnChange="HandleFileSelected" />
            </div>

            @if (IsDataLoaded)
            {
                <button class="btn-reset" @onclick="ResetZoom">⟲ Reset Zoom</button>

                <div class="control-group">
                    <label>X Axis:</label>
                    <select @onchange="OnXAxisChanged">
                        <option value="DeviceTime">Device Time (Default)</option>
                        <option value="Index">Index (Sequence)</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Sensors:</label>
                    <div class="sensor-dropdown">
                        <button class="btn-dropdown">Select Sensors ▼</button>
                        <div class="dropdown-content">
                            @foreach (var sensor in AvailableSensors)
                            {
                                <label>
                                    <input type="checkbox"
                                           checked="@SelectedSensors.Contains(sensor)"
                                           @onchange="@(e => ToggleSensor(sensor, (bool)e.Value))" />
                                    @sensor
                                </label>
                            }
                        </div>
                    </div>
                </div>
            }
        </div>

        <div class="chart-container">
            <canvas id="logChart"></canvas>
        </div>
        
        <div id="scrollbarContainer" class="scrollbar-container" style="display: none;">
            <label class="scrollbar-label">Navigation:</label>
            <input type="range" id="chartScrollbar" class="chart-scrollbar" />
        </div>

        <div class="info-panel">
            @if (CurrentPoint != null)
            {
                <div>
                    <strong>Selected Point (@CurrentIndex):</strong>
                    Time: @CurrentPoint.DeviceTime.ToString() |
                    Time: @CurrentPoint.DeviceTime.ToString("HH:mm:ss") |
                    Speed: @GetValue(CurrentPoint, "Speed (GPS)(km/h)") km/h |
                    RPM: @GetValue(CurrentPoint, "Engine RPM(rpm)")
                </div>
            }
        </div>
    </div>
</div>

<style>
    /* Basic Styles for Split Layout */
    .layout-container {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        overflow: hidden;
    }

    .map-container {
        flex: 1; /* Takes up half or whatever remains */
        min-height: 35vh;
        max-height: 35vh;
        width: 100%;
        z-index: 1;
    }

    .chart-area {
        flex: 1;
        min-height: 40vh;
        display: flex;
        flex-direction: column;
        background-color: #f8f9fa;
        border-top: 2px solid #ccc;
    }

    .controls-bar {
        padding: 10px;
        background: #fff;
        border-bottom: 1px solid #ddd;
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        flex-shrink: 0;
    }

    .control-group {
        display: flex;
        flex-direction: column;
        font-size: 0.8rem;
    }

    .chart-container {
        flex: 1;
        position: relative;
        padding: 10px;
        overflow: hidden;
    }

    .info-panel {
        padding: 5px 10px;
        background: #e9ecef;
        font-size: 0.9rem;
        border-top: 1px solid #ddd;
        flex-shrink: 0;
    }

    /* Simple CSS Dropdown */
    .sensor-dropdown { position: relative; display: inline-block; }
    .btn-dropdown { padding: 5px; cursor: pointer; }
    .dropdown-content {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 250px;
        max-height: 300px;
        overflow-y: auto;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1000;
        padding: 10px;
        border: 1px solid #ccc;
    }
    .sensor-dropdown:hover .dropdown-content { display: block; }
    .dropdown-content label { display: block; margin-bottom: 5px; cursor: pointer; }

    /* Horizontal scrollbar for chart navigation */
    .scrollbar-container {
        padding: 10px;
        background: #fff;
        border-top: 1px solid #ddd;
        display: flex;
        align-items: center;
        gap: 10px;
        flex-shrink: 0;
    }

    .scrollbar-label {
        font-size: 0.85rem;
        font-weight: 500;
        margin: 0;
        white-space: nowrap;
    }

    .chart-scrollbar {
        flex: 1;
        height: 8px;
        -webkit-appearance: none;
        appearance: none;
        background: #e0e0e0;
        border-radius: 5px;
        outline: none;
        cursor: pointer;
    }

    .chart-scrollbar::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 60px;
        height: 20px;
        background: #4CAF50;
        border-radius: 5px;
        cursor: grab;
        transition: background 0.2s;
    }

    .chart-scrollbar::-webkit-slider-thumb:hover {
        background: #45a049;
    }

    .chart-scrollbar::-webkit-slider-thumb:active {
        cursor: grabbing;
        background: #3d8b40;
    }

    .chart-scrollbar::-moz-range-thumb {
        width: 60px;
        height: 20px;
        background: #4CAF50;
        border-radius: 5px;
        border: none;
        cursor: grab;
        transition: background 0.2s;
    }

    .chart-scrollbar::-moz-range-thumb:hover {
        background: #45a049;
    }

    .chart-scrollbar::-moz-range-thumb:active {
        cursor: grabbing;
        background: #3d8b40;
    }
</style>

@code {
    private bool IsDataLoaded = false;
    private List<LogPoint> LogData = new();
    private List<string> AvailableSensors = new();
    private HashSet<string> SelectedSensors = new();

    // Current state
    private LogPoint? CurrentPoint;
    private int CurrentIndex = -1;
    private string XAxisMode = "DeviceTime";

    // Mapping of Portuguese month abbreviations to numbers
    private static readonly Dictionary<string, int> MonthMap = new(StringComparer.OrdinalIgnoreCase)
    {
        { "jan", 1 }, { "fev", 2 }, { "mar", 3 }, { "abr", 4 },
        { "mai", 5 }, { "jun", 6 }, { "jul", 7 }, { "ago", 8 },
        { "set", 9 }, { "out", 10 }, { "nov", 11 }, { "dez", 12 }
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("torqueApp.initMap", DotNetObjectReference.Create(this));
            await JS.InvokeVoidAsync("torqueApp.initChart");
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null) return;

        // Size limit (e.g., 10MB)
        using var stream = file.OpenReadStream(10 * 1024 * 1024);
        using var reader = new StreamReader(stream);

        var content = await reader.ReadToEndAsync();
        ParseCSV(content);
    }

    private void ParseCSV(string csvContent)
    {
        LogData.Clear();
        AvailableSensors.Clear();
        SelectedSensors.Clear();

        var lines = csvContent.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        if (lines.Length < 2) return;

        // Headers
        var headers = lines[0].Split(',');
        // Clean spaces from headers
        for (int i = 0; i < headers.Length; i++) headers[i] = headers[i].Trim();

        // Identify numeric columns (Sensors)
        // Ignore time and lat/lon columns in the list of "plottable" sensors
        var ignoreCols = new[] { "GPS Time", "Device Time", "Longitude", "Latitude" };

        foreach (var h in headers)
        {
            if (!ignoreCols.Contains(h)) AvailableSensors.Add(h);
        }

        // Select some default sensors
        var defaults = new[] { "Speed (GPS)(km/h)", "Engine RPM(rpm)", "Turbo Boost & Vacuum Gauge(bar)" };
        foreach (var d in defaults) if (AvailableSensors.Contains(d)) SelectedSensors.Add(d);

        // Parse lines
        for (int i = 1; i < lines.Length; i++)
        {
            var cols = lines[i].Split(',');
            if (cols.Length != headers.Length) continue;

            var point = new LogPoint();
            point.RawData = new Dictionary<string, double>();

            // Parse Time (Device Time) - Column 1
            var timeStr = cols[1].Trim();
            point.DeviceTime = ParseDeviceTime(timeStr);

            // Parse Lat/Lon (Columns 2 and 3 usually, but we go by name)
            point.Longitude = ParseDouble(cols[Array.IndexOf(headers, "Longitude")]);
            point.Latitude = ParseDouble(cols[Array.IndexOf(headers, "Latitude")]);

            // Parse Sensors
            for (int j = 0; j < headers.Length; j++)
            {
                if (AvailableSensors.Contains(headers[j]))
                {
                    double val = ParseDouble(cols[j]);
                    point.RawData[headers[j]] = val;
                }
            }

            LogData.Add(point);
        }

        IsDataLoaded = true;
        UpdateVisualization();
    }

    private DateTime ParseDeviceTime(string timeStr)
    {
        if (string.IsNullOrWhiteSpace(timeStr))
            return DateTime.MinValue;

        // Expected format: "30-dez-2025 16:15:09.236" or "27-dez.-2025 20:26:16.579"
        // Remove dots after month abbreviations
        timeStr = Regex.Replace(timeStr, @"([a-z]{3})\.", "$1", RegexOptions.IgnoreCase);

        // Try parse with PT-BR culture first
        var culturePt = new CultureInfo("pt-BR");
        if (DateTime.TryParse(timeStr, culturePt, DateTimeStyles.None, out DateTime dt))
            return dt;

        // Manual parse using regex
        // Pattern: DD-MMM-YYYY HH:mm:ss.fff
        var match = Regex.Match(timeStr, @"(\d{1,2})-([a-z]{3})-(\d{4})\s+(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d+))?", RegexOptions.IgnoreCase);
        
        if (match.Success)
        {
            try
            {
                int day = int.Parse(match.Groups[1].Value);
                string monthStr = match.Groups[2].Value.ToLower();
                int year = int.Parse(match.Groups[3].Value);
                int hour = int.Parse(match.Groups[4].Value);
                int minute = int.Parse(match.Groups[5].Value);
                int second = int.Parse(match.Groups[6].Value);
                int millisecond = 0;

                if (match.Groups[7].Success)
                {
                    // Parse milliseconds (may have more or less than 3 digits)
                    string msStr = match.Groups[7].Value;
                    if (msStr.Length > 3) msStr = msStr.Substring(0, 3);
                    millisecond = int.Parse(msStr.PadRight(3, '0'));
                }

                if (MonthMap.TryGetValue(monthStr, out int month))
                {
                    return new DateTime(year, month, day, hour, minute, second, millisecond);
                }
            }
            catch
            {
                // If it fails, return MinValue
            }
        }

        return DateTime.MinValue;
    }

    private double ParseDouble(string val)
    {
        if (string.IsNullOrWhiteSpace(val) || val.Trim() == "-") return 0;
        // Try invariant culture (dot)
        if (double.TryParse(val, NumberStyles.Any, CultureInfo.InvariantCulture, out double res)) return res;
        return 0;
    }

    private void UpdateVisualization()
    {
        if (!IsDataLoaded) return;

        // 1. Update Map (Route)
        // Filter points with valid lat/lon (different from 0 or null if possible)
        var route = LogData
            .Where(p => p.Latitude != 0 && p.Longitude != 0)
            .Select(p => new[] { p.Latitude, p.Longitude })
            .ToList();

        JS.InvokeVoidAsync("torqueApp.drawRoute", route);

        // 2. Update Chart
        UpdateChartData();
    }

    private void UpdateChartData()
    {
        // Prepare Labels (X Axis)
        string[] labels;
        if (XAxisMode == "DeviceTime")
            labels = LogData.Select(x => x.DeviceTime.ToString("HH:mm:ss")).ToArray();
        else
            labels = LogData.Select((x, i) => i.ToString()).ToArray();

        // Prepare Datasets
        var datasets = new List<object>();

        string[] colors = { "#FF5733", "#33FF57", "#3357FF", "#FF33F6", "#33FFF6", "#F3FF33", "#FF8C33" };
        int colorIdx = 0;

        foreach (var sensor in SelectedSensors)
        {
            // Get raw data
            var rawData = LogData.Select(p => p.RawData.ContainsKey(sensor) ? p.RawData[sensor] : 0).ToArray();

            // Normalization Logic (Min-Max Scaling)
            double min = rawData.Min();
            double max = rawData.Max();
            double range = max - min;

            // If range is 0 (constant value), set to 0.5 (middle of chart), otherwise normalize between 0 and 1
            var normalizedData = rawData.Select(v => range == 0 ? 0.5 : (v - min) / range).ToArray();

            datasets.Add(new
            {
                label = sensor,
                data = normalizedData,       // Chart.js draws this (0.0 to 1.0)
                originalData = rawData,      // REAL data to show in Tooltip
                borderColor = colors[colorIdx % colors.Length],
                backgroundColor = "transparent",
                borderWidth = 2,
                pointRadius = 0,
                pointHoverRadius = 4,
                tension = 0.1 // Smooths the line slightly
            });
            colorIdx++;
        }

        JS.InvokeVoidAsync("torqueApp.updateChart", labels, datasets);
    }

    private void ToggleSensor(string sensor, bool isChecked)
    {
        if (isChecked) SelectedSensors.Add(sensor);
        else SelectedSensors.Remove(sensor);
        UpdateChartData();
    }

    private void OnXAxisChanged(ChangeEventArgs e)
    {
        XAxisMode = e.Value?.ToString() ?? "DeviceTime";
        UpdateChartData();
    }

    // Called by JS when the map is clicked
    [JSInvokable]
    public void OnMapClick(double lat, double lng)
    {
        // Find the closest point in the list
        // (This is a simple linear search, for giant logs using KD-Tree would be better, but C# WASM handles ~10k points well)
        var closest = LogData
            .Select((p, index) => new { Point = p, Index = index, Dist = Math.Pow(p.Latitude - lat, 2) + Math.Pow(p.Longitude - lng, 2) })
            .OrderBy(x => x.Dist)
            .FirstOrDefault();

        if (closest != null)
        {
            SelectPoint(closest.Index);
        }
    }

    // Called by JS when the chart is clicked
    [JSInvokable]
    public void OnChartClick(int index)
    {
        SelectPoint(index);
    }

    private void SelectPoint(int index)
    {
        if (index < 0 || index >= LogData.Count) return;

        CurrentIndex = index;
        CurrentPoint = LogData[index];
        StateHasChanged();

        // 1. Update visual on map
        JS.InvokeVoidAsync("torqueApp.highlightPointOnMap", CurrentPoint.Latitude, CurrentPoint.Longitude);

        // 2. Update visual on chart
        JS.InvokeVoidAsync("torqueApp.highlightPointOnChart", index);
    }

    private string GetValue(LogPoint p, string key)
    {
        if (p.RawData.ContainsKey(key)) return p.RawData[key].ToString("F2");
        return "-";
    }

    // Internal Model Class
    public class LogPoint
    {
        public DateTime DeviceTime { get; set; }
        public double Latitude { get; set; }
        public double Longitude { get; set; }
        public Dictionary<string, double> RawData { get; set; } = new();
    }

    // Method invoked by JavaScript when pressing Left (-1) or Right (1) arrow keys
    [JSInvokable]
    public void MoveSelection(int direction)
    {
        if (!IsDataLoaded || LogData.Count == 0) return;

        // Calculate the new index
        int newIndex = CurrentIndex + direction;

        // Safety limits
        if (newIndex < 0) newIndex = 0;
        if (newIndex >= LogData.Count) newIndex = LogData.Count - 1;

        // If it changed, select
        if (newIndex != CurrentIndex)
        {
            SelectPoint(newIndex);
        }
    }

    private async Task ResetZoom()
    {
        await JS.InvokeVoidAsync("torqueApp.resetChartZoom");
    }
}