@inject IJSRuntime JS

<div class="sensor-sidebar @(IsExpanded ? "expanded" : "collapsed")">
    <button class="sidebar-toggle" @onclick="ToggleSidebar" title="@(IsExpanded ? "Collapse sidebar" : "Expand sidebar")">
        @if (IsExpanded)
        {
            <span>&times;</span>
        }
        else
        {
            <span>&#9776;</span>
        }
    </button>

    @if (IsExpanded)
    {
        <div class="sidebar-content">
            <div class="sidebar-header">
                <h3>Sensors</h3>
                <div class="sensor-count">
                    <span class="selected-count">@SelectedSensors.Count selected</span>
                    <span class="total-count">/ @AvailableSensors.Count total</span>
                </div>
            </div>

            <div class="filter-section">
                <input type="text" 
                       class="filter-input" 
                       placeholder="&#128269; Filter sensors..." 
                       @bind="FilterText" 
                       @bind:event="oninput"
                       @onkeyup="OnFilterChanged" />
                @if (!string.IsNullOrWhiteSpace(FilterText))
                {
                    <button class="clear-filter" @onclick="ClearFilter" title="Clear filter">&times;</button>
                }
            </div>

            @if (SelectedSensors.Count > 0)
            {
                <div class="sensor-section selected-section">
                    <div class="section-header">
                        <span class="section-title">Selected (@SelectedSensors.Count)</span>
                        @if (SelectedSensors.Count > 0)
                        {
                            <button class="clear-all-btn" @onclick="ClearAllSelections" title="Clear all selections">
                                Clear All
                            </button>
                        }
                    </div>
                    <div class="sensor-list">
                        @foreach (var sensor in GetFilteredSelectedSensors())
                        {
                            <div class="sensor-item selected" @key="sensor">
                                <label>
                                    <input type="checkbox"
                                           checked="@SelectedSensors.Contains(sensor)"
                                           @onchange="@(e => OnSensorToggled(sensor, (bool)e.Value!))" />
                                    <span class="sensor-color" style="background-color: @GetSensorColor(sensor);"></span>
                                    <span class="sensor-name">@sensor</span>
                                    <div class="sensor-stats">
                                        <span class="sensor-stat-min" title="Minimum value"><span class="icon-min">&#9660;</span> @GetSensorMin(sensor)</span>
                                        <span class="sensor-stat-max" title="Maximum value"><span class="icon-max">&#9650;</span> @GetSensorMax(sensor)</span>
                                        <span class="sensor-value" title="Current value">@GetSensorValue(sensor)</span>
                                    </div>
                                </label>
                            </div>
                        }
                    </div>
                </div>
            }

            <div class="sensors-scrollable">
                <div class="sensor-section available-section">
                    <div class="section-header">
                        <span class="section-title">Available (@GetFilteredAvailableSensors().Count())</span>
                    </div>
                    <div class="sensor-list">
                        @{
                            var availableSensors = GetFilteredAvailableSensors();
                            if (availableSensors.Any())
                            {
                                @foreach (var sensor in availableSensors)
                                {
                                    <div class="sensor-item" @key="sensor">
                                        <label>
                                            <input type="checkbox"
                                                   checked="@SelectedSensors.Contains(sensor)"
                                                   @onchange="@(e => OnSensorToggled(sensor, (bool)e.Value!))" />
                                            <span class="sensor-name">@sensor</span>
                                            <div class="sensor-stats">
                                                <span class="sensor-stat-min" title="Minimum value"><span class="icon-min">&#9660;</span> @GetSensorMin(sensor)</span>
                                                <span class="sensor-stat-max" title="Maximum value"><span class="icon-max">&#9650;</span> @GetSensorMax(sensor)</span>
                                                <span class="sensor-value" title="Current value">@GetSensorValue(sensor)</span>
                                            </div>
                                        </label>
                                    </div>
                                }
                            }
                            else if (!string.IsNullOrWhiteSpace(FilterText))
                            {
                                <div class="no-results">
                                    No sensors match your filter.
                                </div>
                            }
                        }
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter]
    public List<string> AvailableSensors { get; set; } = new();

    [Parameter]
    public HashSet<string> SelectedSensors { get; set; } = new();

    [Parameter]
    public Dictionary<string, string> SensorColorMapping { get; set; } = new();

    [Parameter]
    public EventCallback<(string sensor, bool isSelected)> OnSensorToggle { get; set; }

    [Parameter]
    public bool IsExpanded { get; set; } = true;

    [Parameter]
    public EventCallback<bool> IsExpandedChanged { get; set; }

    [Parameter]
    public object? CurrentPoint { get; set; }

    [Parameter]
    public object? AllLogData { get; set; }

    private string FilterText { get; set; } = string.Empty;

    // Cache for min/max values
    private Dictionary<string, (double min, double max)> _sensorMinMaxCache = new();

    private void ToggleSidebar()
    {
        IsExpanded = !IsExpanded;
        IsExpandedChanged.InvokeAsync(IsExpanded);
    }

    private void OnFilterChanged()
    {
        StateHasChanged();
    }

    private void ClearFilter()
    {
        FilterText = string.Empty;
        StateHasChanged();
    }

    private void OnSensorToggled(string sensor, bool isSelected)
    {
        OnSensorToggle.InvokeAsync((sensor, isSelected));
    }

    private void ClearAllSelections()
    {
        // Create a copy to avoid modification during iteration
        var sensorsToRemove = SelectedSensors.ToList();
        foreach (var sensor in sensorsToRemove)
        {
            OnSensorToggled(sensor, false);
        }
    }

    private IEnumerable<string> GetFilteredSelectedSensors()
    {
        if (string.IsNullOrWhiteSpace(FilterText))
            return SelectedSensors.OrderBy(s => s);

        return SelectedSensors
            .Where(s => s.Contains(FilterText, StringComparison.OrdinalIgnoreCase))
            .OrderBy(s => s);
    }

    private IEnumerable<string> GetFilteredAvailableSensors()
    {
        var available = AvailableSensors.Except(SelectedSensors);

        if (string.IsNullOrWhiteSpace(FilterText))
            return available.OrderBy(s => s);

        return available
            .Where(s => s.Contains(FilterText, StringComparison.OrdinalIgnoreCase))
            .OrderBy(s => s);
    }

    private string GetSensorColor(string sensor)
    {
        return SensorColorMapping.ContainsKey(sensor) ? SensorColorMapping[sensor] : "#999";
    }

    private string GetSensorValue(string sensor)
    {
        if (CurrentPoint == null) return "-";

        // Use reflection to get RawData property
        var pointType = CurrentPoint.GetType();
        var rawDataProperty = pointType.GetProperty("RawData");
        
        if (rawDataProperty == null) return "-";

        var rawData = rawDataProperty.GetValue(CurrentPoint) as Dictionary<string, double>;
        
        if (rawData == null || !rawData.ContainsKey(sensor)) return "-";

        return rawData[sensor].ToString("F2");
    }

    private string GetSensorMin(string sensor)
    {
        var minMax = GetSensorMinMax(sensor);
        return minMax.min != double.MaxValue ? minMax.min.ToString("F2") : "-";
    }

    private string GetSensorMax(string sensor)
    {
        var minMax = GetSensorMinMax(sensor);
        return minMax.max != double.MinValue ? minMax.max.ToString("F2") : "-";
    }

    private (double min, double max) GetSensorMinMax(string sensor)
    {
        // Check cache first
        if (_sensorMinMaxCache.ContainsKey(sensor))
        {
            return _sensorMinMaxCache[sensor];
        }

        if (AllLogData == null) return (double.MaxValue, double.MinValue);

        // Use reflection to get the list
        var listType = AllLogData.GetType();
        if (!listType.IsGenericType) return (double.MaxValue, double.MinValue);

        var countProperty = listType.GetProperty("Count");
        if (countProperty == null) return (double.MaxValue, double.MinValue);

        int count = (int)countProperty.GetValue(AllLogData)!;
        if (count == 0) return (double.MaxValue, double.MinValue);

        var indexer = listType.GetProperty("Item");
        if (indexer == null) return (double.MaxValue, double.MinValue);

        double min = double.MaxValue;
        double max = double.MinValue;

        for (int i = 0; i < count; i++)
        {
            var point = indexer.GetValue(AllLogData, new object[] { i });
            if (point == null) continue;

            var rawDataProperty = point.GetType().GetProperty("RawData");
            if (rawDataProperty == null) continue;

            var rawData = rawDataProperty.GetValue(point) as Dictionary<string, double>;
            if (rawData == null || !rawData.ContainsKey(sensor)) continue;

            double value = rawData[sensor];
            if (value < min) min = value;
            if (value > max) max = value;
        }

        // Cache the result
        var result = (min, max);
        _sensorMinMaxCache[sensor] = result;
        
        return result;
    }

    protected override void OnParametersSet()
    {
        // Clear cache when AllLogData changes
        if (AllLogData != null)
        {
            _sensorMinMaxCache.Clear();
        }
    }
}
