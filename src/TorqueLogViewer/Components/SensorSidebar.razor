@inject IJSRuntime JS
@implements IDisposable

<div class="sensor-sidebar @(IsExpanded ? "expanded" : "collapsed")">
    <button class="sidebar-toggle" @onclick="ToggleSidebar" title="@(IsExpanded ? "Collapse sidebar" : "Expand sidebar")">
        @if (IsExpanded)
        {
            <span>&times;</span>
        }
        else
        {
            <span>&#9776;</span>
        }
    </button>

    @if (IsExpanded)
    {
        <div class="sidebar-content">
            <div class="sidebar-header">
                <h3>Sensors</h3>
                <div class="sensor-count">
                    <span class="selected-count">@SelectedSensors.Count selected</span>
                    <span class="total-count">/ @AvailableSensors.Count total</span>
                </div>
            </div>

            <div class="filter-section">
                <input type="text" 
                       class="filter-input" 
                       placeholder="&#128269; Filter sensors..." 
                       @bind="FilterText" 
                       @bind:event="oninput"
                       @onkeyup="OnFilterChanged" />
                @if (!string.IsNullOrWhiteSpace(FilterText))
                {
                    <button class="clear-filter" @onclick="ClearFilter" title="Clear filter">&times;</button>
                }
            </div>

            @if (SelectedSensors.Count > 0)
            {
                <div class="sensor-section selected-section">
                    <div class="section-header">
                        <span class="section-title">Selected (@SelectedSensors.Count)</span>
                        @if (SelectedSensors.Count > 0)
                        {
                            <button class="clear-all-btn" @onclick="ClearAllSelections" title="Clear all selections">
                                Clear All
                            </button>
                        }
                    </div>
                    <div class="sensor-list">
                        @foreach (var sensor in GetFilteredSelectedSensors())
                        {
                            <div class="sensor-item selected" @key="sensor">
                                <label>
                                    <input type="checkbox"
                                           checked="@SelectedSensors.Contains(sensor)"
                                           @onchange="@(e => OnSensorToggled(sensor, (bool)e.Value!))" />
                                    <span class="sensor-color" style="background-color: @GetSensorColor(sensor);"></span>
                                    <span class="sensor-name">@sensor</span>
                                    <div class="sensor-stats">
                                        <span class="sensor-stat-min" title="Minimum value"><span class="icon-min">&#9660;</span> @GetSensorMin(sensor)</span>
                                        <span class="sensor-stat-max" title="Maximum value"><span class="icon-max">&#9650;</span> @GetSensorMax(sensor)</span>
                                        <span class="sensor-value" title="Current value">@GetCurrentSensorValue(sensor)</span>
                                    </div>
                                </label>
                            </div>
                        }
                    </div>
                </div>
            }

            <div class="sensors-scrollable">
                <div class="sensor-section available-section">
                    <div class="section-header">
                        <span class="section-title">Available (@GetFilteredAvailableSensors().Count())</span>
                    </div>
                    <div class="sensor-list">
                        @{
                            var availableSensors = GetFilteredAvailableSensors();
                            if (availableSensors.Any())
                            {
                                @foreach (var sensor in availableSensors)
                                {
                                    <div class="sensor-item" @key="sensor">
                                        <label>
                                            <input type="checkbox"
                                                   checked="@SelectedSensors.Contains(sensor)"
                                                   @onchange="@(e => OnSensorToggled(sensor, (bool)e.Value!))" />
                                            <span class="sensor-name">@sensor</span>
                                            <div class="sensor-stats">
                                                <span class="sensor-stat-min" title="Minimum value"><span class="icon-min">&#9660;</span> @GetSensorMin(sensor)</span>
                                                <span class="sensor-stat-max" title="Maximum value"><span class="icon-max">&#9650;</span> @GetSensorMax(sensor)</span>
                                                <span class="sensor-value" title="Current value">@GetCurrentSensorValue(sensor)</span>
                                            </div>
                                        </label>
                                    </div>
                                }
                            }
                            else if (!string.IsNullOrWhiteSpace(FilterText))
                            {
                                <div class="no-results">
                                    No sensors match your filter.
                                </div>
                            }
                        }
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter]
    public List<string> AvailableSensors { get; set; } = new();

    [Parameter]
    public HashSet<string> SelectedSensors { get; set; } = new();

    [Parameter]
    public Dictionary<string, string> SensorColorMapping { get; set; } = new();

    [Parameter]
    public EventCallback<(string sensor, bool isSelected)> OnSensorToggle { get; set; }

    [Parameter]
    public bool IsExpanded { get; set; } = true;

    [Parameter]
    public EventCallback<bool> IsExpandedChanged { get; set; }

    [Parameter]
    public object? CurrentPoint { get; set; }

    [Parameter]
    public object? AllLogData { get; set; }

    private string FilterText { get; set; } = string.Empty;

    // Cache for min/max values
    private Dictionary<string, (double min, double max)> _sensorMinMaxCache = new();
    
    // Cache for current values - updated only when CurrentPoint changes
    private Dictionary<string, double> _currentValuesCache = new();
    private object? _lastCurrentPoint = null;

    private void ToggleSidebar()
    {
        IsExpanded = !IsExpanded;
        IsExpandedChanged.InvokeAsync(IsExpanded);
    }

    private void OnFilterChanged()
    {
        StateHasChanged();
    }

    private void ClearFilter()
    {
        FilterText = string.Empty;
        StateHasChanged();
    }

    private void OnSensorToggled(string sensor, bool isSelected)
    {
        OnSensorToggle.InvokeAsync((sensor, isSelected));
    }

    private void ClearAllSelections()
    {
        // Create a copy to avoid modification during iteration
        var sensorsToRemove = SelectedSensors.ToList();
        foreach (var sensor in sensorsToRemove)
        {
            OnSensorToggled(sensor, false);
        }
    }

    private IEnumerable<string> GetFilteredSelectedSensors()
    {
        if (string.IsNullOrWhiteSpace(FilterText))
            return SelectedSensors.OrderBy(s => s);

        return SelectedSensors
            .Where(s => s.Contains(FilterText, StringComparison.OrdinalIgnoreCase))
            .OrderBy(s => s);
    }

    private IEnumerable<string> GetFilteredAvailableSensors()
    {
        var available = AvailableSensors.Except(SelectedSensors);

        if (string.IsNullOrWhiteSpace(FilterText))
            return available.OrderBy(s => s);

        return available
            .Where(s => s.Contains(FilterText, StringComparison.OrdinalIgnoreCase))
            .OrderBy(s => s);
    }

    private string GetSensorColor(string sensor)
    {
        return SensorColorMapping.ContainsKey(sensor) ? SensorColorMapping[sensor] : "#999";
    }

    private void UpdateCurrentValuesCache()
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss.fff}] SensorSidebar.UpdateCurrentValuesCache: Started");
        
        _currentValuesCache.Clear();
        
        if (CurrentPoint == null)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SensorSidebar.UpdateCurrentValuesCache: CurrentPoint is null");
            return;
        }

        var step1Time = DateTime.Now;
        
        // Use reflection to get RawData property
        var pointType = CurrentPoint.GetType();
        var rawDataProperty = pointType.GetProperty("RawData");
        
        if (rawDataProperty == null)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SensorSidebar.UpdateCurrentValuesCache: RawData property not found");
            return;
        }

        var step2Time = DateTime.Now;
        var rawData = rawDataProperty.GetValue(CurrentPoint) as Dictionary<string, double>;
        
        if (rawData == null)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SensorSidebar.UpdateCurrentValuesCache: RawData is null");
            return;
        }

        var step3Time = DateTime.Now;
        
        // Cache all values at once
        foreach (var kvp in rawData)
        {
            _currentValuesCache[kvp.Key] = kvp.Value;
        }
        
        var endTime = DateTime.Now;
        var totalDuration = (endTime - startTime).TotalMilliseconds;
        Console.WriteLine($"[{endTime:HH:mm:ss.fff}] SensorSidebar.UpdateCurrentValuesCache: Completed (cached {_currentValuesCache.Count} values, duration: {totalDuration:F2}ms)");
    }

    private string GetCurrentSensorValue(string sensor)
    {
        if (_currentValuesCache.TryGetValue(sensor, out double value))
        {
            return value.ToString("F2");
        }
        
        return "-";
    }

    private string GetSensorMin(string sensor)
    {
        var minMax = GetSensorMinMax(sensor);
        return minMax.min != double.MaxValue ? minMax.min.ToString("F2") : "-";
    }

    private string GetSensorMax(string sensor)
    {
        var minMax = GetSensorMinMax(sensor);
        return minMax.max != double.MinValue ? minMax.max.ToString("F2") : "-";
    }

    private (double min, double max) GetSensorMinMax(string sensor)
    {
        // Check cache first
        if (_sensorMinMaxCache.ContainsKey(sensor))
        {
            return _sensorMinMaxCache[sensor];
        }

        if (AllLogData == null) return (double.MaxValue, double.MinValue);

        // Use reflection to get the list
        var listType = AllLogData.GetType();
        if (!listType.IsGenericType) return (double.MaxValue, double.MinValue);

        var countProperty = listType.GetProperty("Count");
        if (countProperty == null) return (double.MaxValue, double.MinValue);

        int count = (int)countProperty.GetValue(AllLogData)!;
        if (count == 0) return (double.MaxValue, double.MinValue);

        var indexer = listType.GetProperty("Item");
        if (indexer == null) return (double.MaxValue, double.MinValue);

        double min = double.MaxValue;
        double max = double.MinValue;

        for (int i = 0; i < count; i++)
        {
            var point = indexer.GetValue(AllLogData, new object[] { i });
            if (point == null) continue;

            var rawDataProperty = point.GetType().GetProperty("RawData");
            if (rawDataProperty == null) continue;

            var rawData = rawDataProperty.GetValue(point) as Dictionary<string, double>;
            if (rawData == null || !rawData.ContainsKey(sensor)) continue;

            double value = rawData[sensor];
            if (value < min) min = value;
            if (value > max) max = value;
        }

        // Cache the result
        var result = (min, max);
        _sensorMinMaxCache[sensor] = result;
        
        return result;
    }

    protected override void OnParametersSet()
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss.fff}] SensorSidebar.OnParametersSet: Started");
        
        // Clear min/max cache when AllLogData changes
        if (AllLogData != null && _sensorMinMaxCache.Count == 0)
        {
            _sensorMinMaxCache.Clear();
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SensorSidebar.OnParametersSet: Cleared min/max cache");
        }
        
        // Update current values cache only if CurrentPoint actually changed
        if (CurrentPoint != _lastCurrentPoint)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SensorSidebar.OnParametersSet: CurrentPoint changed, updating cache");
            _lastCurrentPoint = CurrentPoint;
            UpdateCurrentValuesCache();
        }
        
        var endTime = DateTime.Now;
        var duration = (endTime - startTime).TotalMilliseconds;
        Console.WriteLine($"[{endTime:HH:mm:ss.fff}] SensorSidebar.OnParametersSet: Completed (duration: {duration:F2}ms)");
    }

    protected override bool ShouldRender()
    {
        var startTime = DateTime.Now;
        Console.WriteLine($"[{startTime:HH:mm:ss.fff}] SensorSidebar.ShouldRender: Checking if render needed");
        
        // Always render for now, but log it so we can see how often it's called
        var endTime = DateTime.Now;
        var duration = (endTime - startTime).TotalMilliseconds;
        Console.WriteLine($"[{endTime:HH:mm:ss.fff}] SensorSidebar.ShouldRender: Returning true (duration: {duration:F2}ms)");
        
        return true;
    }

    public void Dispose()
    {
        _sensorMinMaxCache.Clear();
        _currentValuesCache.Clear();
    }
}
